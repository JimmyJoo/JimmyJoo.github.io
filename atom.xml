<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JIMMY JOO&#39;s DEVLOG</title>
  
  <subtitle>Jimmy Joo&#39;s Dev Travel Journal</subtitle>
  <link href="https://jimmyjoo.github.io/atom.xml" rel="self"/>
  
  <link href="https://jimmyjoo.github.io/"/>
  <updated>2020-09-23T00:46:42.098Z</updated>
  <id>https://jimmyjoo.github.io/</id>
  
  <author>
    <name>Jimmy Joo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>프로그래머스 - 시저암호</title>
    <link href="https://jimmyjoo.github.io/2020/09/21/algorithms/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EC%8B%9C%EC%A0%80%EC%95%94%ED%98%B8/"/>
    <id>https://jimmyjoo.github.io/2020/09/21/algorithms/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EC%8B%9C%EC%A0%80%EC%95%94%ED%98%B8/</id>
    <published>2020-09-20T23:43:19.000Z</published>
    <updated>2020-09-23T00:46:42.098Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p><strong>LINK</strong>: <a href="https://programmers.co.kr/learn/courses/30/lessons/12926">프로그래머스 - 시저암호</a></p><br><h2 id="문제-📝"><a href="#문제-📝" class="headerlink" title="문제 📝"></a><strong>문제</strong> 📝</h2><p><img src="https://user-images.githubusercontent.com/67693474/93947653-3f1ca980-fd77-11ea-9acf-ce88f3b4c895.png" alt=""></p><hr><h2 id="나의-풀이-🤔"><a href="#나의-풀이-🤔" class="headerlink" title="나의 풀이 🤔"></a><strong>나의 풀이</strong> 🤔</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">s, n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1️⃣</span></span><br><span class="line">  <span class="keyword">const</span> charArr = <span class="string">'abcdefghijklmnopqrstuvwxyz'</span>.split(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2️⃣</span></span><br><span class="line">  <span class="keyword">const</span> chars = s.split(<span class="string">''</span>).map(<span class="function">(<span class="params">char</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 3️⃣</span></span><br><span class="line">    <span class="keyword">const</span> index = charArr.indexOf(char.toLowerCase());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4️⃣</span></span><br><span class="line">    <span class="keyword">return</span> index &lt; <span class="number">0</span></span><br><span class="line">      ? <span class="string">' '</span></span><br><span class="line">      : <span class="regexp">/[a-z]/</span>.test(char)</span><br><span class="line">      ? charArr[(index + n) % <span class="number">26</span>]</span><br><span class="line">      : charArr[(index + n) % <span class="number">26</span>].toUpperCase();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5️⃣</span></span><br><span class="line">  <span class="keyword">return</span> chars.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1️⃣ 먼저 알파벳을 요소로 하는 배열을 만든다.</p><p>2️⃣ 주어진 문자열 s를 <code>split(&#39;&#39;)</code>메서드를 이용하여 배열로 만들어준다. 이때 공백(<code>&#39; &#39;</code>) 또한 요소로 들어간다. 그리고 그 배열을 순회하며 다음 로직을 사용한다.</p><p>3️⃣ 아까 만든 배열의 요소를 순회하며 요소를 소문자로 만들고 그 소문자로 만든 요소가 <code>charArr</code>의 몇번째 인덱스에 있는지 확인한다. 이때 공백이라면 <code>charArr</code>에 없기 때문에 <code>-1</code>을 리턴한다.</p><p>4️⃣ 따라서, 먼저 공백인 경우는 그대로 공백을 리턴하게 한다. 그 이후 공백이 아니라면, 정규표현식을 통해 소문자인경우를 확인한다. 소문자인 경우, 아까 찾은 인덱스에서 n을 더한 값에 <code>%</code>(나머지 연산, 모듈로 연산)을 하여 새로운 알파벳을 리턴한다. 주어진 값이 대문자인 경우, 소문자와 마찬가지로 똑같은 연산을 하고 얻은 알파벳을 대문자화시켜 리턴한다.</p><p>5️⃣ 마지막으로, <code>join(&#39;&#39;)</code>메서드를 활용하여 문자열로 만들어준다.</p><hr><h2 id="다른-분의-풀이-👏"><a href="#다른-분의-풀이-👏" class="headerlink" title="다른 분의 풀이 👏"></a><strong>다른 분의 풀이</strong> 👏</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">s, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 1️⃣</span></span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">      result += <span class="string">' '</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 2️⃣</span></span><br><span class="line">      result += <span class="built_in">String</span>.fromCharCode(</span><br><span class="line">        s.charCodeAt(i) &gt; <span class="number">90</span></span><br><span class="line">          ? ((s.charCodeAt(i) + n - <span class="number">97</span>) % <span class="number">26</span>) + <span class="number">97</span></span><br><span class="line">          : ((s.charCodeAt(i) + n - <span class="number">65</span>) % <span class="number">26</span>) + <span class="number">65</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉 큰 차이점은 <code>charCodeAt()</code> 메서드를 활용하여 유니코드적인 관점에서 해결한다. <code>charCodeAt</code>는 주어진 인덱스에 대한 유니코드를 나타내는 0부터 65535 사이의 정수를 리턴한다. 이때 알파벳 대문자는 65<del>90, 소문자는 97</del>122까지 정수이다.</p><p>1️⃣ 공백일 경우 공백을 리턴한다.</p><p>2️⃣ <code>s.charCodeAt(i) &gt; 90</code>를 통해서 대소문자를 체크한다(<code>true</code>라면 소문자, <code>false</code>라면 대문자). 그리고 n만큼 더하고 97이나 65만큼 뺀 후에 나머지 연산을 해주게 되면 n을 더했을 때 알파벳 범위(65<del>90이나 97</del>122)를 벗어날 경우를 해결해준다. 마지막으로 다시 97이나 65만큼 더하게 되면 A나 a를 나타내는 유니코드로부터 시작해서 나머지 연산으로 얻어진 인덱스를 만큼 더한 새로운 유니코드를 얻을 수 있다. <code>String.fromCharCode()</code> 메서드를 통해 유니코드를 문자로 바꿔준다.</p><hr><h2 id="관련-학습-내용-🔎"><a href="#관련-학습-내용-🔎" class="headerlink" title="관련 학습 내용 🔎"></a><strong>관련 학습 내용</strong> 🔎</h2><p><a href="https://jimmyjoo.github.io">정규표현식</a> 📚</p><hr><hr><br><p><strong>참고</strong>👏</p><ul><li><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt">MDN - charCodeAt()</a></p></li><li><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode">MDN - String.fromCharCode()</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="algorithms" scheme="https://jimmyjoo.github.io/categories/algorithms/"/>
    
    
    <category term="algorithms" scheme="https://jimmyjoo.github.io/tags/algorithms/"/>
    
    <category term="programmers" scheme="https://jimmyjoo.github.io/tags/programmers/"/>
    
  </entry>
  
  <entry>
    <title>프로그래머스 - 소수 찾기</title>
    <link href="https://jimmyjoo.github.io/2020/09/19/algorithms/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EC%86%8C%EC%88%98%EC%B0%BE%EA%B8%B0/"/>
    <id>https://jimmyjoo.github.io/2020/09/19/algorithms/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EC%86%8C%EC%88%98%EC%B0%BE%EA%B8%B0/</id>
    <published>2020-09-19T01:43:19.000Z</published>
    <updated>2020-09-19T06:39:51.288Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p><strong>LINK</strong>: <a href="https://programmers.co.kr/learn/courses/30/lessons/12921#" rel="external nofollow noopener noreferrer" target="_blank">프로그래머스 - 소수 찾기</a></p><br><h2 id="문제-📝"><a href="#문제-📝" class="headerlink" title="문제 📝"></a><strong>문제</strong> 📝</h2><p><img src="https://user-images.githubusercontent.com/67693474/93656409-3b321400-fa65-11ea-9831-3152a3f7ef09.png" alt></p><hr><h2 id="나의-풀이-🤔"><a href="#나의-풀이-🤔" class="headerlink" title="나의 풀이 🤔"></a><strong>나의 풀이</strong> 🤔</h2><p>1️⃣</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  outer: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">2</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i % j === <span class="number">0</span>) <span class="keyword">continue</span> outer;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉 매우 단순하고 정직한 방법이다. (너무 정직한게 문제..😅). 풀이 그대로 n만큼 순회하면서 각 i마다 또 j만큼 순회한다. 각 i마다 자기 자신보다 작은(<code>j &lt; i</code>) 수에서 나누어 떨어지는 수(<code>i%j===0</code>)가 있다면 다음 수로 넘어간다. 자기 자신보다 하나 작은 수까지 체크하고 나누어 떨어지는 수가 없다면 count를 증가시킨다.</p><p>👉 이 풀이의 시간복잡도는 <strong><code>O(n^2)</code></strong>. (상수는 고려하지 않기 때문에)</p><p>👉 결과는? 처참하다… 😫</p><img width="367" src="https://user-images.githubusercontent.com/67693474/93657576-d24f9980-fa6e-11ea-89d3-bb5f3273e4c1.png"><br><br><p>2️⃣<br>그래서 맨 처음 든 생각은 2를 제외한 짝수는 어차피 소수가 될 수 없다.<br><strong>홀수만 체크하자.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line">  outer: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">2</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i % j === <span class="number">0</span>) <span class="keyword">continue</span> outer;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉 2는 항상 유일한 짝수이자 소수이기 때문에 <code>count</code>를 1부터 시작하게 하고 <code>for</code>문에서 i를 홀수부터 시작하게 하였다. 문제에서 n은 2부터 주어지기 때문에 n이 1인 경우는 신경 쓰지 않아도 된다. 그리고 n이 2인 경우에는 for문이 한번도 순회하지 않는다.</p><p>👉 홀수만 체크하더라도 각 홀수마다 i번을 체크하게된다. 따라서, 시간 복잡도에선 상수를 무시하기 때문에 결국 <strong><code>O(n^2)</code></strong>.</p><p>👉 결과는? 마찬가지로 실패 😢</p><img width="367" src="https://user-images.githubusercontent.com/67693474/93657795-679f5d80-fa70-11ea-92ad-00580a17793a.png"><br><br><p>3️⃣<br>🧐각 숫자마다 for문을 더 적게 돌아보자!<br>즉, <strong>소수 판별 알고리즘이 너무 비효율적</strong>이다(O(n)).<br>이를 개선시켜보자!<br>어떤 숫자 k가 소수인지 아닌지 확인하기 위해서 2부터 k까지 다 확인할 필요가 있을까?<br>그건 확실히 아닌거같다. 그렇다면 어디까지 확인해봐야하지??<br>첫 번째로 절반만 확인해보자. 왜 절반이지?<br>k = 100이라면 51부터는 100에 어떤수를 대입해도 나누어 떨어지지 않는다. (100 % 51, 100 % 82, …)</p><p>이 개념을 좀 더 확장시켜서 <strong>약수</strong>의 개념으로 바라본다면??<br>예를 들어, k = 100이고 100의 약수를 구해보자.<br>1, 2, 4, 5, 10, 20, 25, 50, 100<br>여기서, 1과 100이 pair, 2와 50이 pair, 4와 25가 pair. 즉 모든 약수는 하나의 pair로 이루어져있다. 그리고 그 pair에 중에서 작은 수만 확인하면된다. 왜냐면 100이 2로 나누어떨어진다는 말은 50으로도 나누어 떨어진다는 뜻이다. 마찬가지로 100이 25로 나누어 떨어진다는 소리는 4로도 나누어 떨어진다는 뜻이다. 그렇기에 약수중에서 작은 수들만 어떻게 알 수 있을까? 바로 <strong>제곱근(sqrt)</strong>이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  outer: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">2</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i % j === <span class="number">0</span>) <span class="keyword">continue</span> outer;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉 각 숫자마다 제곱근만큼 체크한다. 따라서, 각 숫자에 소수 판별 알고리즘은 <strong><code>O(sqrt(n))</code></strong>. 하지만 모든 숫자를 체크하기때문에 <strong><code>O(n sqrt(n))</code></strong></p><p>👉 결과는? 효율성 테스트 실패 😢<br><img width="371" src="https://user-images.githubusercontent.com/67693474/93658819-f4024e00-fa79-11ea-87c3-5e2597f385ca.png"></p><br><br><p>4️⃣<br>2️⃣ + 3️⃣ = ?<br>홀수만 체크하고(2️⃣) 각 숫자마다 <code>sqrt()</code>까지만 순회함으로써 <code>for</code>문을 좀 더 적게 순회하자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line">  outer: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">2</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i % j === <span class="number">0</span>) <span class="keyword">continue</span> outer;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉 결과는? 마찬가지로 효율성 테스트 실패 😢</p><img width="367" src="https://user-images.githubusercontent.com/67693474/93658974-5e67be00-fa7b-11ea-9a76-0e595ff13e8f.png"><br><br><p>5️⃣<br>결국 인터넷의 도움을 받았다.🧐<br>사용한 알고리즘은 <strong>에라토스테네스의 체!!</strong><br>이 알고리즘은 다음과 같다.<br>배열에 모든 수를 넣고 2부터 검사한다. 2를 넣으면 2의 배수들은 다 지우고, 그 다음 3을 넣으면 3의 배수들을 다 지운다. 그리고 마지막에 지워지지 않은 숫자가 소수임을 확인할 수 있다.</p><p><img src="https://user-images.githubusercontent.com/67693474/93659046-29a83680-fa7c-11ea-8721-f48591a793d9.gif" alt></p><p>출처: <a href="https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4" rel="external nofollow noopener noreferrer" target="_blank">위키피디아 - 에라토스테네스의 체</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1부터 100까지 숫자들을 담은 배열은 만든다.</span></span><br><span class="line">  <span class="keyword">const</span> arr = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: n &#125;, (_, i) =&gt; i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 첫번째 1은 소수가 아니기에 0으로 만들어준다.</span></span><br><span class="line">  arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3️⃣풀이같이 제곱근까지만 순회한다.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="comment">// 만약 숫자가 0이라면 이미 다른 수의 배수라는 뜻이기 때문에 확인해줄 필요가 없다. 따라서, 0이 아닌 숫자에 한해서만 체크를 한다.</span></span><br><span class="line">    <span class="keyword">if</span> (arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="comment">// 그 숫자의 배수들을 0으로 만들어준다. 이때 j의 시작은 i*i로 만들어준다.</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = i * i; j &lt;= n; j += i) &#123;</span><br><span class="line">        arr[j - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 마지막으로 0이 아닌 숫자로 배열을 만들어서 길이를 확인한다.</span></span><br><span class="line">  <span class="keyword">const</span> count = arr.filter(<span class="function">(<span class="params">v</span>) =&gt;</span> v).length;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉 j의 시작점은 <code>i * i</code>로 해준다. 그 이유는 i보다 작은 수의 배수는 이미 검사가 되었기 때문이다. j = <code>(i*2)</code> ~ <code>(i * (i - i))</code> 인 구간은 순회할 필요가 없다는 뜻이다.</p><p>예를 들어 i가 4라고 해보자. 그러면 8(<code>4 * 2</code>) ~ 12(<code>4 * (4 - 1))</code>인 구간에서 4의 배수를 확인할 필요가 없다. 그 이유는, 8은 <code>i(4) * 2</code>이기 때문에 2의 배수이므로 이미 체크 되어 있다. 마찬가지로, 12는 <code>i(4) * 3</code>이기 때문에 3의 배수이므로 이미 체크 되어 있다. 따라서, <code>i * (i - 1)</code>는 <code>(i - 1)</code>의 배수이므로 이미 체크 되어 있기 때문에 <code>i * i</code>부터 시작하면 좀 더 효율적으로 검사할 수 있다.</p><p>👉 이 알고리즘의 시간복잡도는 <strong><code>O(n log logn)</code></strong></p><p>👉 결과는? 성공! 👏<br><img width="365" src="https://user-images.githubusercontent.com/67693474/93660511-b0fca680-fa8a-11ea-8d47-5ac7c692669a.png"></p><hr><h2 id="다른-분의-풀이-👏"><a href="#다른-분의-풀이-👏" class="headerlink" title="다른 분의 풀이 👏"></a><strong>다른 분의 풀이</strong> 👏</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line">  for (let i = 1; i &lt;= n; i += 2) &#123;</span><br><span class="line">    <span class="keyword">set</span>.add(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span>.delete(1);</span><br><span class="line">  <span class="keyword">set</span>.add(2);</span><br><span class="line">  for (let j = 3; j &lt; Math.sqrt(n); j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">set</span>.has(j)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k = j * <span class="number">2</span>; k &lt;= n; k += j) &#123;</span><br><span class="line">        <span class="keyword">set</span>.delete(k);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return <span class="keyword">set</span>.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉 가장 큰 차이점은 배열이 아니라 <code>Set</code>객체를 활용하였다. 먼저 홀수만 체크한다. 그러기 위해 세트안에 홀수만 담는다. 그리고 1은 제거하고 2를 추가한다. 그 이후 <code>Set</code>를 순회하면서 에라토스테네스의 체 알고리즘을 사용하였다. 그 과정에서 배수인 요소들을 아예 삭제해준다.</p><p>👉 배열을 사용하지 않았기에 마지막에 <code>filter</code>를 돌면서 한번 더 n번만큼 순회하지 않아도 되는점이 효율적이다.</p><p>👉 개선할 점은 <code>k=j*2</code>. 위에서도 설명하였듯이 k가 <code>j * 2</code>부터 <code>j * (j-1)</code>까지는 순회하지 않아도 된다. 따라서, <code>k=j*j</code>로 하는게 더 효율적이다.</p><hr><h2 id="관련-학습-내용-🔎"><a href="#관련-학습-내용-🔎" class="headerlink" title="관련 학습 내용 🔎"></a><strong>관련 학습 내용</strong> 🔎</h2><p><a href="https://jimmyjoo.github.io">자바스크립트 Set</a> 📚</p><hr><hr><br><p><strong>참고</strong>👏</p><ul><li><p><a href="https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4" rel="external nofollow noopener noreferrer" target="_blank">위키피디아 - 에라토스테네스의 체</a></p></li><li><p><a href="https://www.weeklyps.com/entry/에라토스테네스의-체-소수-구하기#d2" rel="external nofollow noopener noreferrer" target="_blank">에라토스테네스의-체-소수-구하기</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="algorithms" scheme="https://jimmyjoo.github.io/categories/algorithms/"/>
    
    
    <category term="algorithms" scheme="https://jimmyjoo.github.io/tags/algorithms/"/>
    
    <category term="programmers" scheme="https://jimmyjoo.github.io/tags/programmers/"/>
    
  </entry>
  
  <entry>
    <title>프로그래머스 - 같은 숫자는 싫어</title>
    <link href="https://jimmyjoo.github.io/2020/09/18/algorithms/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EA%B0%99%EC%9D%80%EC%88%AB%EC%9E%90%EB%8A%94%EC%8B%AB%EC%96%B4/"/>
    <id>https://jimmyjoo.github.io/2020/09/18/algorithms/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EA%B0%99%EC%9D%80%EC%88%AB%EC%9E%90%EB%8A%94%EC%8B%AB%EC%96%B4/</id>
    <published>2020-09-18T09:28:11.000Z</published>
    <updated>2020-09-18T11:47:25.136Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p><strong>LINK</strong>: <a href="https://programmers.co.kr/learn/courses/30/lessons/12906">프로그래머스 - 같은 숫자는 싫어</a></p><br><h2 id="문제-📝"><a href="#문제-📝" class="headerlink" title="문제 📝"></a><strong>문제</strong> 📝</h2><p><img src="https://user-images.githubusercontent.com/67693474/93593709-8f021600-f9ef-11ea-8aa1-01540dacc16b.png" alt=""></p><hr><h2 id="나의-풀이-🤔"><a href="#나의-풀이-🤔" class="headerlink" title="나의 풀이 🤔"></a><strong>나의 풀이</strong> 🤔</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">value, index</span>) =&gt;</span> value !== arr[index + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉 주어진 배열 <code>arr</code>에서 특정한 조건(연속된 숫자 제거)을 만족하는 요소들만 추출하여 새로운 배열을 필요로 하기에 <code>filter</code> 메서드를 사용하였다. 조건을 확인하는 방법은 <code>value</code>(현재 인덱스의 요소)와 그 `arr<a href="다음요소">index+1</a>를 비교해서 다른 경우에만 새롭게 반환할 배열에 들어가도록 한다.</p><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="algorithms" scheme="https://jimmyjoo.github.io/categories/algorithms/"/>
    
    
    <category term="algorithms" scheme="https://jimmyjoo.github.io/tags/algorithms/"/>
    
    <category term="programmers" scheme="https://jimmyjoo.github.io/tags/programmers/"/>
    
  </entry>
  
  <entry>
    <title>프로그래머스 - 2016</title>
    <link href="https://jimmyjoo.github.io/2020/09/17/algorithms/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_2016/"/>
    <id>https://jimmyjoo.github.io/2020/09/17/algorithms/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_2016/</id>
    <published>2020-09-16T23:19:11.000Z</published>
    <updated>2020-09-18T11:40:08.314Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p><strong>LINK</strong>: <a href="https://programmers.co.kr/learn/courses/30/lessons/12901">프로그래머스 - 2016</a></p><br><h2 id="문제-📝"><a href="#문제-📝" class="headerlink" title="문제 📝"></a><strong>문제</strong> 📝</h2><p><img src="https://user-images.githubusercontent.com/67693474/93420659-5fb5b100-f8ea-11ea-93aa-eac3daf659c6.png" alt=""></p><hr><h2 id="나의-풀이-🤔"><a href="#나의-풀이-🤔" class="headerlink" title="나의 풀이 🤔"></a><strong>나의 풀이</strong> 🤔</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1️⃣</span></span><br><span class="line">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">`2016/<span class="subst">$&#123;a&#125;</span>/<span class="subst">$&#123;b&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2️⃣</span></span><br><span class="line">  <span class="keyword">const</span> day = date.getDay();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3️⃣</span></span><br><span class="line">  <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'SUN'</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'MON'</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'TUE'</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'WED'</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'THU'</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'FRI'</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'SAT'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1️⃣ 날짜 문자열을 통해 <code>Date</code> 객체를 만들어준다.</p><p>2️⃣ <code>getDay()</code> 메소드를 통해 요일에 맞는 숫자(0~6)을 <code>day</code>라는 변수에 할당한다.</p><p>3️⃣ <code>switch</code>문을 통해 알맞은 요일 문자열을 리턴한다.</p><hr><h2 id="다른-분의-풀이-👏"><a href="#다른-분의-풀이-👏" class="headerlink" title="다른 분의 풀이 👏"></a><strong>다른 분의 풀이</strong> 👏</h2><p>1️⃣</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dayArr = [<span class="string">'SUN'</span>, <span class="string">'MON'</span>, <span class="string">'TUE'</span>, <span class="string">'WED'</span>, <span class="string">'THU'</span>, <span class="string">'FRI'</span>, <span class="string">'SAT'</span>];</span><br><span class="line">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">`2016-<span class="subst">$&#123;a&#125;</span>-<span class="subst">$&#123;b&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> day = date.getDay();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dayArr[day];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉 이 분의 접근방식은 요일 문자열들을 미리 배열로 담아놓는다. <code>getDay()</code>가 요일에 맞게 0~6의 숫자를 리턴하니까 그에 맞는 배열의 요소를 리턴한다. <code>switch</code>문이 아니라 배열을 사용하여 코드의 길이로 훨씬 줄어들었다. 👍</p><br><p>2️⃣</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2016</span>, a - <span class="number">1</span>, b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> date.toString().slice(<span class="number">0</span>, <span class="number">3</span>).toUpperCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉 <code>date</code> 객체를 만들어준다. (위에서는 문자열로 <code>Date</code>객체를 만들었다. 하지만 이번에는 연,월,일을 <code>,</code>를 기준으로 하나 하나 인수로 넘겨준다. 이때 주의할점은 월은 0~11까지의 정수이다. 즉, 0이 1월, 1이 2월. 따라서, 달 - 1을 해주어야한다). <code>date</code>객체에 <code>toString()</code>메소드를 사용하면 <code>Tue May 24 2016 00:00:00 GMT+0900 (Korean Standard Time)</code> 이런식으로 문자열로 날짜객체를 리턴해준다. (<code>toDateString()</code>도 사용할 수 있다. 사용할경우 시간이 생략된 <code>Tue May 24 2016</code>만 리턴한다). 그리고 <code>slice(0,3)</code>을 통해 앞에 3글자만 가져오고 <code>toUpperCase()</code>메소드를 통해 대문자화시켜준 값을 리턴한다.</p><hr><h2 id="관련-학습-내용-🔎"><a href="#관련-학습-내용-🔎" class="headerlink" title="관련 학습 내용 🔎"></a><strong>관련 학습 내용</strong> 🔎</h2><p><a href="https://jimmyjoo.github.io/">Date 객체</a> 📚</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="algorithms" scheme="https://jimmyjoo.github.io/categories/algorithms/"/>
    
    
    <category term="algorithms" scheme="https://jimmyjoo.github.io/tags/algorithms/"/>
    
    <category term="programmers" scheme="https://jimmyjoo.github.io/tags/programmers/"/>
    
  </entry>
  
  <entry>
    <title>배열 메소드 Slice() vs Splice()</title>
    <link href="https://jimmyjoo.github.io/2020/09/16/js/Slice%EC%99%80Splice/"/>
    <id>https://jimmyjoo.github.io/2020/09/16/js/Slice%EC%99%80Splice/</id>
    <published>2020-09-16T07:04:21.000Z</published>
    <updated>2020-09-18T11:41:04.831Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h2 id="slice-📍"><a href="#slice-📍" class="headerlink" title="slice() 📍"></a><strong>slice()</strong> 📍</h2><p><code>array.slice([start[, end]])</code></p><p>👉<code>slice()</code> 메서드는 <strong>어떤 배열의 begin부터 end까지(end 미포함)에 대한 얕은 복사본을 새로운 배열 객체로 반환</strong>한다. 이떄, <strong>원본 배열은 바뀌지 않는다.</strong></p><p>👉<strong>리턴값</strong><br><strong>추출한 요소를 포함한 새로운 배열</strong></p><p>👉<strong>매개변수</strong><br>1️⃣<strong>start(optional): 복사를 시작할 인덱스</strong><br>• <strong>음수</strong>인 경우: 배열의 끝부터의 길이를 나타낸다. <code>slice(-2)</code>인 경우 마지막 2개의 요소를 추출해서 리턴한다.<br>• <code>undefined</code>인 경우: 0부터 slice한다.<br>• <strong>배열의 길이보다 크거나 같은</strong> 경우: 빈 배열을 리턴한다.</p><p>2️⃣<strong>end(optional): 복사를 종료할 인덱스(이 인덱스는 포함하지 않는다.)</strong><br>• <strong>지정하지 않은</strong> 경우: 배열의 끝까지 slice한다.<br>• <strong>음수</strong>인 경우: 배열의 끝에서부터의 길이를 나타낸다. <code>slice(2, -1)</code>를 하면 세번째부터 끝에서 두번째 요소까지 추출해서 리턴한다<br>• <strong>배열의 길이보다 크거나 같은</strong> 경우: 배열의 끝까지 추출해서 리턴한다.</p><p>예시를 통해 자세히 살펴보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1️⃣ start와 end가 모두 주어진 경우,</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">1</span>, <span class="number">3</span>)); <span class="comment">// [2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// start 인덱스가 undefined면 0과 같다.</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="literal">undefined</span>, <span class="number">3</span>)); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// start 인덱스가 음수면 뒤에서부터 시작해서 end 인덱스 전까지 추출한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">-4</span>, <span class="number">4</span>)); <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// start 인덱스의 요소가 end 인덱스의 요소보다 나중에 위치할 경우 빈 배열을 리턴한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">-2</span>, <span class="number">2</span>)); <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2️⃣ start 인덱스만 주어진 경우, 주어진 인덱스부터 끝까지 추출한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">2</span>)); <span class="comment">// [3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 아무것도 없거나 0이거나 undefined면 전부 추출한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice()); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">0</span>)); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="literal">undefined</span>)); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// start 인덱스가 음수인 경우, 뒤에서부터 추출한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">-3</span>)); <span class="comment">// [3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 음수인데 절대값이 배열의 요소보다 큰 경우, 전부 추출한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">-10</span>)); <span class="comment">// -&gt; [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><br><p>👉<strong>slice() 메서드를 통해 만들어지는 복사본 배열은 얕은 복사(shallow copy)를 통해 생성된다.</strong></p><p>🧐<strong>얕은 복사?</strong><br>객체(객체리터럴, 배열 등등)를 프로퍼티 값으로 갖는 객체의 경우,<br>(배열 안에 객체, 객체 안에 배열, 배열 안에 배열 등등)<br>객체를 복사할 때 <strong>얕은 복사</strong>와 <strong>깊은 복사</strong>로 구분할 수 있다.<br><strong>얕은 복사</strong>는 한 단계까지만 복사하는 것을 말하고 <strong>깊은 복사</strong>는 모두 복사하는 것을 말한다.</p><p>더 자세한 내용은 👉 <a href="">얕은 복사 vs 깊은 복사</a></p><br><p>예시를 통해 살펴보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copy = arr.slice();</span><br><span class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(copy === arr); <span class="comment">// false. slice()를 통해 만들어진 복사본은 새로운 배열이다. 배열은 객체이고 따라서 참조값은 다르기 때문에 false.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 복사본은 얕은 복사를 통해 생성된다.</span></span><br><span class="line"><span class="keyword">const</span> todos = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">'HTML'</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">content</span>: <span class="string">'CSS'</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">content</span>: <span class="string">'JS'</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todosCopy = todos.slice();</span><br><span class="line"><span class="built_in">console</span>.log(todos === todosCopy); <span class="comment">// false.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 얕은 복사로 인해 todos의 요소(객체)는 참조값이 같다.</span></span><br><span class="line"><span class="built_in">console</span>.log(todos[<span class="number">0</span>] === todosCopy[<span class="number">1</span>]); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 따라서 todosCopy의 프로퍼티를 변경하게 되면 todos의 요소에도 변경사항이 적용된다.</span></span><br><span class="line">todosCopy[<span class="number">2</span>].id = <span class="number">30</span>;</span><br><span class="line">todosCopy[<span class="number">2</span>].content = <span class="string">'React'</span>;</span><br><span class="line">todosCopy[<span class="number">2</span>].completed = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(todos[<span class="number">2</span>]); <span class="comment">//&#123;id: 30, content: 'React', completed: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(todosCopy[<span class="number">2</span>]); <span class="comment">// &#123;id: 30, content: 'React', completed: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 단, 아래의 경우는 새로운 객체를 할당하는 것이 때문에 todosCopy[1]에게 새로운 객체의 참조값을 할당하는 것이다. 따라서 todos[1]에게는 변경 사항이 적용되지 않는다.</span></span><br><span class="line">todosCopy[<span class="number">1</span>] = &#123; <span class="attr">id</span>: <span class="number">20</span>, <span class="attr">content</span>: <span class="string">'Sass'</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(todosCopy[<span class="number">1</span>]); <span class="comment">// &#123;id: 20, content: 'Sass', completed: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(todos[<span class="number">1</span>]); <span class="comment">// &#123; id: 2, content: 'CSS', completed: true &#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="splice-📍"><a href="#splice-📍" class="headerlink" title="splice() 📍"></a><strong>splice()</strong> 📍</h2><p><code>array.splice(start[, deleteCount[, item1[, item2[, ...]]]])</code></p><p>👉<code>splice()</code> 메서드는 <strong>배열의 기존 요소를 삭제 또는 교체하거나 새 요소를 추가하여 배열의 내용을 변경</strong>한다. 이때, <strong>원본 배열은 바뀐다.</strong></p><p>👉<strong>리턴값</strong><br><strong>제거한 요소를 담은 배열</strong></p><p>👉<strong>매개변수</strong><br>1️⃣<strong>start: 배열의 변경을 시작할 인덱스</strong><br>• <strong>음수</strong>인 경우: 배열의 끝에서부터 요소를 센다.<br>• <strong>배열의 길이보다 크거나 같은</strong> 경우: 시작 인덱스는 배열의 길이로 설정된다.<br>• <strong>절대값이 배열의 길이보다 큰 경우</strong> 경우: 0으로 세팅된다.</p><p>2️⃣<strong>deleteCount(optional): 배열에서 제거할 요소의 수</strong><br>• <strong>지정하지 않은</strong> 경우: 시작 인덱스부터 모든 요소를 제거한다.<br>• <strong>(배열의 길이 - 시작 인덱스)보다 큰</strong> 경우: 시작 인덱스부터 모든 요소를 제거한다.<br>• <strong>0 이하</strong>인 경우: 어떤 요소도 제거되지 않는다.</p><p>3️⃣<strong>item1, item2,…(optional): 배열에 추가할 요소</strong><br>• 아무것도 지정하지 않으면 <code>splice()</code>메서드는 요소를 제거만 한다.</p><br><p>예시를 통해 자세히 살펴보자.</p><ul><li>요소를 변경하는 경우</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인덱스 1부터 2개의 요소를 20과 30으로 변경한다.</span></span><br><span class="line"><span class="keyword">const</span> result = arr.splice(<span class="number">1</span>, <span class="number">2</span>, <span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제거한 요소가 배열로 리턴된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 원본 배열을 변경한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 20, 30, 4, 5]</span></span><br></pre></td></tr></table></figure><br><ul><li>요소를 제거하는 경우(item1, item2,…을 생략한다.)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인덱스 1부터 2개의 요소를 제거한다.</span></span><br><span class="line"><span class="keyword">const</span> result1 = arr1.splice(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제거한 요소가 배열로 리턴된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(result1); <span class="comment">// [2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 원본 배열을 변경한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 20, 30, 4, 5]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인덱스 1부터 모든 요소를 제거한다.</span></span><br><span class="line"><span class="keyword">const</span> result2 = arr2.splice(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result2); <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure><br><ul><li>요소를 제거하지 않고 요소를 추가하는 경우(두번째 인수를 0을 넣어준다.)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인덱스 1부터 0개의 요소를 제거하고 20과 30을 추가한다.</span></span><br><span class="line"><span class="keyword">const</span> result = arr.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제거한 요소가 배열로 리턴된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 원본 배열을 변경한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 20, 30, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><hr><br><p><strong>참고</strong>👏</p><ul><li><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/slice">MDN - slice()</a></p></li><li><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/splice">MDN - splice()</a></p></li><li><p><a href="https://im-developer.tistory.com/103">slice()와 splice()의 차이점</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/tags/javascript/"/>
    
    <category term="array" scheme="https://jimmyjoo.github.io/tags/array/"/>
    
    <category term="slice" scheme="https://jimmyjoo.github.io/tags/slice/"/>
    
    <category term="splice" scheme="https://jimmyjoo.github.io/tags/splice/"/>
    
  </entry>
  
  <entry>
    <title>프로그래머스 - K번째수</title>
    <link href="https://jimmyjoo.github.io/2020/09/16/algorithms/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_K%EB%B2%88%EC%A7%B8%EC%88%98/"/>
    <id>https://jimmyjoo.github.io/2020/09/16/algorithms/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_K%EB%B2%88%EC%A7%B8%EC%88%98/</id>
    <published>2020-09-16T05:14:19.000Z</published>
    <updated>2020-09-18T11:40:37.102Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p><strong>LINK</strong>: <a href="https://programmers.co.kr/learn/courses/30/lessons/42748">프로그래머스 - K번째 수</a></p><br><h2 id="문제-📝"><a href="#문제-📝" class="headerlink" title="문제 📝"></a><strong>문제</strong> 📝</h2><p><img src="https://user-images.githubusercontent.com/67693474/93300878-93350480-f832-11ea-8993-d15dd8d9d4b7.png" alt=""></p><hr><h2 id="나의-풀이-🤔"><a href="#나의-풀이-🤔" class="headerlink" title="나의 풀이 🤔"></a><strong>나의 풀이</strong> 🤔</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">array, commands</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1️⃣</span></span><br><span class="line">  <span class="keyword">return</span> commands.reduce(<span class="function">(<span class="params">acc, cur, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 2️⃣</span></span><br><span class="line">    acc[i] = array.slice(cur[<span class="number">0</span>] - <span class="number">1</span>, cur[<span class="number">1</span>]).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)[cur[<span class="number">2</span>] - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3️⃣</span></span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1️⃣ <code>reduce</code>를 사용해서 접근하였다. <code>reduce</code>의 콜백함수에 매개변수로 <code>acc</code>, <code>cur</code>, <code>i</code>를 넘겨주었다. 여기서 <code>acc</code>는 초기값으로 빈배열을 넣어주었고 나중에 k번째 수를 넣어줄 배열이다. <code>cur</code>는 commands배열의 요소(마찬가지로 배열)이다.</p><p>2️⃣ <code>slice</code>를 사용하여서 배열을 자르고 <code>sort</code>메소드로 정렬시킨다. <code>slice</code>는 “mutator method”라서 원본 배열을 건드리지 않고 새로운 배열을 반환한다. 마지막으로 잘라진 크기의 새로운 배열에서 원하는 인덱스의 요소를 가져와서 <code>acc[i]</code>에 할당한다.</p><p>3️⃣ <code>acc</code>(k번째 숫자를 담는 배열)을 리턴시킨다.</p><hr><h2 id="다른-분의-풀이-👏"><a href="#다른-분의-풀이-👏" class="headerlink" title="다른 분의 풀이 👏"></a><strong>다른 분의 풀이</strong> 👏</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">array, commands</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> commands.map(<span class="function">(<span class="params">[start, end, k]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> array.slice(start - <span class="number">1</span>, end).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)[k - <span class="number">1</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉 차이점은 <code>reduce</code>가 아니라 <code>map</code>을 활용해서 접근하였다. 그리고 <code>map</code>의 콜백함수의 첫번째 매개변수를 배열 디스트럭쳐링을 통해 인덱스가 무엇을 의미하는지 좀 더 파악하기 쉽게 표현되었다.</p><hr><h2 id="관련-학습-내용-🔎"><a href="#관련-학습-내용-🔎" class="headerlink" title="관련 학습 내용 🔎"></a><strong>관련 학습 내용</strong> 🔎</h2><p><a href="https://jimmyjoo.github.io/2020/09/16/js/SliceVsSplice/">배열 메소드 slice() vs splice()</a> 📚</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="algorithms" scheme="https://jimmyjoo.github.io/categories/algorithms/"/>
    
    
    <category term="algorithms" scheme="https://jimmyjoo.github.io/tags/algorithms/"/>
    
    <category term="programmers" scheme="https://jimmyjoo.github.io/tags/programmers/"/>
    
  </entry>
  
  <entry>
    <title>프로그래머스 - 두 개 뽑아서 더하기</title>
    <link href="https://jimmyjoo.github.io/2020/09/15/algorithms/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EB%91%90%EA%B0%9C%EB%BD%91%EC%95%84%EC%84%9C%EB%8D%94%ED%95%98%EA%B8%B0/"/>
    <id>https://jimmyjoo.github.io/2020/09/15/algorithms/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EB%91%90%EA%B0%9C%EB%BD%91%EC%95%84%EC%84%9C%EB%8D%94%ED%95%98%EA%B8%B0/</id>
    <published>2020-09-15T10:11:39.000Z</published>
    <updated>2020-09-18T11:40:49.168Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p><strong>LINK</strong>: <a href="https://programmers.co.kr/learn/courses/30/lessons/68644">프로그래머스 - 두 개 뽑아서 더하기</a></p><br><h2 id="문제-📝"><a href="#문제-📝" class="headerlink" title="문제 📝"></a><strong>문제</strong> 📝</h2><p><img src="https://user-images.githubusercontent.com/67693474/93208331-61bb2b00-f797-11ea-972f-288960b03b8b.png" alt=""></p><hr><h2 id="나의-풀이-🤔"><a href="#나의-풀이-🤔" class="headerlink" title="나의 풀이 🤔"></a><strong>나의 풀이</strong> 🤔</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1️⃣</span></span><br><span class="line">  <span class="keyword">const</span> sumArr = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2️⃣</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; numbers.length; j++) &#123;</span><br><span class="line">      sumArr.push(numbers[i] + numbers[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3️⃣</span></span><br><span class="line">  <span class="keyword">const</span> answer = [...new <span class="built_in">Set</span>(sumArr)].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1️⃣ 두 개의 수를 저장할 배열(sumArr)을 <code>const</code> 키워드로 선언해준다. 2️⃣에서 배열에 두 수의 합을 <code>push</code>를 해줄거지만 배열자체의 reference가 재할당(re-assign)이 되지 않기 때문에 문제가 되지 않는다.</p><p>2️⃣ numbers 배열을 이중순회하면서 요소들을 더하고 결과를 sumArr에 push한다. 바깥 <code>for</code>문은 총 numbers.length-1만큼 순회한다. numbers.length만큼보다 하나 작은 이유는 마지막 요소는 어차피 그 다음 요소가 없기 때문에 더할것이 없고 안쪽 <code>for</code>문도 무시된다. 따라서 애초에 바깥 <code>for</code>문을 시작할 필요조차 없다. 안쪽 <code>for</code>문의 경우 인덱스(j)는 i보다 하나 큰 수에서 시작한다.</p><p>3️⃣ <code>new Set(sumArr)</code>을 통해 중복요소를 제거해준 Set을 만든다. 그 다음 배열의 요소들을 정렬하기 위해 유용한 메서드 <code>sort()</code>를 사용하려고 한다. 그러나 Set은 배열이 아니라 사용하지 못하기 때문에 객체디스트럭쳐링을 한 이후에 배열 안에 담아준다. 그리고 오름차순으로 정렬시킨다.</p><hr><h2 id="관련-학습-내용-🔎"><a href="#관련-학습-내용-🔎" class="headerlink" title="관련 학습 내용 🔎"></a><strong>관련 학습 내용</strong> 🔎</h2><p><a href="https://jimmyjoo.github.io">자바스크립트 Set</a> 📚</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="algorithms" scheme="https://jimmyjoo.github.io/categories/algorithms/"/>
    
    
    <category term="algorithms" scheme="https://jimmyjoo.github.io/tags/algorithms/"/>
    
    <category term="programmers" scheme="https://jimmyjoo.github.io/tags/programmers/"/>
    
  </entry>
  
  <entry>
    <title>배열 정렬 메소드, Sort()</title>
    <link href="https://jimmyjoo.github.io/2020/09/14/js/Sort/"/>
    <id>https://jimmyjoo.github.io/2020/09/14/js/Sort/</id>
    <published>2020-09-14T04:04:21.000Z</published>
    <updated>2020-09-17T05:22:30.097Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h2 id="sort-메서드란-📍"><a href="#sort-메서드란-📍" class="headerlink" title="sort() 메서드란? 📍"></a><strong>sort() 메서드란?</strong> 📍</h2><p><code>sort()</code> 메서드는 배열의 요소를 적절하게 정렬할 때 유용하다.</p><p>(오름차순👆 또는 내림차순👇)</p><p>그렇다면 먼저 어떻게 생겼는지(문법)에 대해 살펴보자! 😎</p><hr><h2 id="문법-📍"><a href="#문법-📍" class="headerlink" title="문법 📍"></a><strong>문법</strong> 📍</h2><p><code>array.sort([compareFunction])</code></p><p><strong>매개변수(parameter)</strong>로 <strong>비교함수</strong>를 받을 수 있다.</p><p>( 좀 더 자세한 설명은 아래서 👇)</p><hr><h2 id="설명-📍"><a href="#설명-📍" class="headerlink" title="설명 📍"></a><strong>설명</strong> 📍</h2><p><code>sort</code> 메서드는 <strong>원본 배열을 직접 변경하여 정렬된 배열을 반환</strong>한다.<br>(이렇게 원본 배열을 직접 변경하는 메소드를 “mutator method”라고 부른다.<br>이와 상반되는 메소드는 “accessor method”라고 부른다. 예를 들어, <code>map</code>이나 <code>filter</code> 메소드는 원본 배열을 변경하지 않고 새로운 배열을 생성하여 반환한다. )</p><p>기본 <strong>정렬 순서</strong>는 오름차순이다.<br>하지만 정확히 표현하자면 <strong>문자열의 유니코드 코드 포인트</strong>를 따른다!<br>따라서, 배열의 요소가 숫자 타입이여도 배열의 요소를 일시적으로 문자열로 변환 후 문자열의 유니코드를 비교하여 정렬한다.</p><p>예시 코드를 보며 좀 더 살펴보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1️⃣ 과일배열(fruits) 정렬</span></span><br><span class="line"><span class="keyword">const</span> fruits = [<span class="string">'Banana'</span>, <span class="string">'Apple'</span>, <span class="string">'Orange'</span>];</span><br><span class="line">fruits.sort();</span><br><span class="line"><span class="built_in">console</span>.log(fruits);</span><br><span class="line"><span class="comment">// ['Apple', 'Banana', 'Orange']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2️⃣ 점수배열(scores) 정렬</span></span><br><span class="line"><span class="keyword">const</span> scores = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">100</span>];</span><br><span class="line">scores.sort();</span><br><span class="line"><span class="built_in">console</span>.log(scores);</span><br><span class="line"><span class="comment">// [1, 10, 100, 2, 3]</span></span><br></pre></td></tr></table></figure><hr><p>👉 먼저 1️⃣, 2️⃣ 케이스 둘 다 <strong>원본 배열이 수정</strong>되었다.</p><p>👉 1️⃣부터 살펴보자. “abcdefg~”🎶 알파벳 순서대로 잘 정렬되었다. 👍</p><p>👉 문자열을 비교할때는 Unicode 값으로 비교하며 한 글자씩 비교한다.<br>‘J’ &gt; ‘a’는 <code>false</code>: 알파벳은 Unicode에서 대문자 이후에 소문자가 오기 때문에 소문자가 더 크다.</p><p>‘Java’ &gt; ‘a’는 <code>false</code>: 한 글자씩 비교한다.</p><p>‘Java’ &gt; ‘Apple’는 <code>true</code>: 한 글자씩 비교한다. (‘J’와 ‘A’를 비교하면 같은 대문자고 ‘J’가 나중에 오기때문에 <code>true</code>)</p><p>👉 그렇다면 2️⃣는?<br>예상했던 결과는 <code>[1, 2, 3, 10, 100]</code>였지만 막상 결과는 전혀 엉뚱하게 정렬된 배열이다.</p><p><code>[1, 10, 100, 2, 3]</code> ?! 🧐</p><p>그 이유는 <code>sort()</code> 메서드는 <strong>문자열의 유니코드 코드 포인트</strong>에 따라 정렬하기 때문!</p><p>배열의 요소들이 숫자이지만 비교하기 위해서 일시적으로 문자열로 변환된다.<br><code>[2, 3, 10, 1, 100]</code> → <code>[&#39;2&#39;, &#39;3&#39;, &#39;10&#39;, &#39;1&#39;, &#39;100&#39;]</code></p><p>문자열 <code>1</code>의 Unicode 코드 포인트 U+0031<br>문자열 <code>2</code>의 Unicode 코드 포인트 U+0032<br>👉 <code>1</code>의 Unicode 코드 포인트가 앞서므로 <code>1</code>이 <code>2</code>보다 앞으로 정렬된다.</p><p><code>10</code>과 <code>2</code>의 경우<br>문자열 <code>10</code>의 Unicode 코드 포인트 U+0031U+0030<br>문자열 <code>2</code>의 Unicode 코드 포인트 U+0032<br>👉<code>10</code>의 Unicode 코드 포인트가 앞서므로 <code>10</code>이 <code>2</code>보다 앞으로 정렬된다.</p><p>그렇다면 숫자를 정렬할 때 Unicode의 코드 포인트 기준이 아니라 우리가 원래 원했던대로 정렬하고 싶다면 어떻게 해야될까?</p><p>그러기 위해선 <strong>비교함수(Compare function)</strong>에 대해 알아보자! 🔍</p><hr><h2 id="비교-함수-compare-function-📍"><a href="#비교-함수-compare-function-📍" class="headerlink" title="비교 함수(compare function) 📍"></a><strong>비교 함수(compare function)</strong> 📍</h2><p><strong>비교 함수</strong>란 <strong>정렬 순서를 정의하는 함수</strong>이다.</p><p>위에서 살펴보았듯이 생략할 경우 각 문자의 Unicode 코드 포인트 값에 따라 정렬한다.</p><p>비교 함수의 형식은 다음과 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (a is less than b by some ordering criterion) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (a is greater than b by the ordering criterion) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// a must be equal to b</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉비교함수는 두 개의 매개변수(a, b)를 받고 비교함수 내부의 로직을 실행하여 비교한다.</p><p>👉비교함수의 <strong>반환값이 음수면 순서를 그대로 유지</strong>하고<br>반환값이 <strong>양수이면 b를 a보다 우선하여 정렬</strong>한다.<br>반환값이 <strong>0인 경우 서로에 대해 변경하지 않고 모든 다른 요소에 대해 정렬</strong>합니다.<br>(❗️ECMAscript 표준은 이러한 동작을 보장하지 않으므로 모든 브라우저(예 : Mozilla 버전은 적어도 2003 년 이후 버전 임)가 이를 존중하지는 않습니다. )</p><p>다음은 숫자를 오름차순으로 정렬하는 코드이다.<br>천천히 원리를 이해해보자!</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scores = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">100</span>];</span><br><span class="line">scores.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="built_in">console</span>.log(scores);</span><br><span class="line"><span class="comment">// [1, 2, 3, 10, 100]</span></span><br></pre></td></tr></table></figure><p>👉 <code>sort</code> 메소드의 매개변수로 익명 화살표 함수 <code>(a, b) =&gt; a - b</code>를 비교 함수로써 넘겼다.</p><p>❗️쉬운 이해를 위해 매우 간단하게 설명하겠습니다.</p><p>👉 첫번째로, a: 2, b: 3을 대입해서 함수를 실행하면 반환값은 -1(음수)이다. 따라서, 순서는 그대로 유지된다.<br>👉 10과 1를 정렬해보자. 10 - 1 을 해보면 9(양수)를 반환한다. 따라서, 순서는 뒤 바뀌게 되고 1은 10보다 우선 정렬된다.</p><p>❗️구글 크롬의 경우 콘솔로 찍어서 확인해보면 예상과 달리 a는 2가 아니라 3이 온다. 이에 대해서는 좀 더 공부가 필요할것같다. (추측하건대 내부적으로 <code>Timsort</code> 알고리즘을 사용하는데 아마 그것때문이 아닐까…? 🤔)</p><p><img src="https://user-images.githubusercontent.com/67693474/93054065-bda48780-f6a3-11ea-98bf-2dfa3f95a3ea.png" alt=""><br><img src="https://user-images.githubusercontent.com/67693474/93054115-d614a200-f6a3-11ea-9b18-033c47fb1eae.png" alt=""></p><p>👉 하지만, a가 3이고 b를 2로 여긴다는것은 배열의 순서가 [3, 2, …]인 상태이고 반환값이 양수(+)가 되어서 순서가 바뀌게 된다. 즉, 2가 우선 정렬된다는 뜻이다.<br>따라서, 직관적으로 a는 2, b는 3이라고 여겨도 무방하게 같은 정렬된 배열을 얻을 수 있다.</p><hr><h2 id="예제-📍"><a href="#예제-📍" class="headerlink" title="예제 📍"></a><strong>예제</strong> 📍</h2><p><strong>숫자 배열 오름차순 정렬</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scores = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">100</span>];</span><br><span class="line">scores.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="built_in">console</span>.log(scores);</span><br></pre></td></tr></table></figure><p><strong>숫자 배열 내림차순 정렬</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scores = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">100</span>];</span><br><span class="line">scores.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="built_in">console</span>.log(scores);</span><br></pre></td></tr></table></figure><p><strong>비 ASCII 문자 정렬</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [<span class="string">'réservé'</span>, <span class="string">'premier'</span>, <span class="string">'cliché'</span>, <span class="string">'communiqué'</span>, <span class="string">'café'</span>, <span class="string">'adieu'</span>];</span><br><span class="line">items.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.localeCompare(b));</span><br><span class="line"></span><br><span class="line"><span class="comment">// items is ['adieu', 'café', 'cliché', 'communiqué', 'premier', 'réservé']</span></span><br></pre></td></tr></table></figure><p>👉<code>localeCompare()</code> 메서드는 기준 문자열과 비교했을 때 비교 대상 문자열이 정렬상 전에 오는지, 후에 오는지 혹은 같은 순서에 배치되는지를 알려주는 숫자를 리턴한다.</p><p>👉 <code>a.localeCompare(b)</code>일때<br>a가 b보다 전에 오면 -(음수)<br>a가 b보다 후에 오면 +(양수)<br>같으면 0</p><p><strong>객체를 요소로 갖는 배열 정렬</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'Banana'</span>, <span class="attr">price</span>: <span class="number">100</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'Apple'</span>, <span class="attr">price</span>: <span class="number">75</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'Orange'</span>, <span class="attr">price</span>: <span class="number">20</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 비교함수</span></span><br><span class="line"><span class="keyword">const</span> compare = <span class="function">(<span class="params">key</span>) =&gt;</span> <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a[key] &gt; a[key] ? <span class="number">1</span> : a[key] &lt; b[key] ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// name으로 정렬</span></span><br><span class="line"><span class="built_in">console</span>.log(fruits.sort(compare(<span class="string">'name'</span>)));</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  &#123; name: 'Apple', score: 75 &#125;,</span></span><br><span class="line"><span class="comment">  &#123; name: 'Banana', price: 100 &#125;,</span></span><br><span class="line"><span class="comment">  &#123; name: 'Orange', score: 20&#125;,</span></span><br><span class="line"><span class="comment">] </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// price로 정렬</span></span><br><span class="line"><span class="built_in">console</span>.log(fruits.sort(compare(<span class="string">'price'</span>)));</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  &#123; name: 'Orange', score: 20&#125;,</span></span><br><span class="line"><span class="comment">  &#123; name: 'Apple', score: 75 &#125;,</span></span><br><span class="line"><span class="comment">  &#123; name: 'Banana', price: 100 &#125;,</span></span><br><span class="line"><span class="comment">] </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><br><p><strong>참고</strong>👏</p><ul><li><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">MDN - sort()</a></p></li><li><p><a href="https://poiemaweb.com/js-array">PoiemaWeb - 배열</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/tags/javascript/"/>
    
    <category term="array" scheme="https://jimmyjoo.github.io/tags/array/"/>
    
    <category term="sort" scheme="https://jimmyjoo.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>프로그래머스 - 완주하지 못한 선수</title>
    <link href="https://jimmyjoo.github.io/2020/09/14/algorithms/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EC%99%84%EC%A3%BC%ED%95%98%EC%A7%80%EB%AA%BB%ED%95%9C%EC%84%A0%EC%88%98/"/>
    <id>https://jimmyjoo.github.io/2020/09/14/algorithms/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EC%99%84%EC%A3%BC%ED%95%98%EC%A7%80%EB%AA%BB%ED%95%9C%EC%84%A0%EC%88%98/</id>
    <published>2020-09-14T02:12:39.000Z</published>
    <updated>2020-09-18T11:40:25.026Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p><strong>LINK</strong>: <a href="https://programmers.co.kr/learn/courses/30/lessons/42576">프로그래머스 - 완주하지 못한 선수</a></p><br><h2 id="문제-📝"><a href="#문제-📝" class="headerlink" title="문제 📝"></a><strong>문제</strong> 📝</h2><p><img src="https://user-images.githubusercontent.com/67693474/93043481-e8cfac80-f68c-11ea-88d3-d637793e736c.png" alt=""></p><hr><h2 id="나의-풀이-🤔"><a href="#나의-풀이-🤔" class="headerlink" title="나의 풀이 🤔"></a><strong>나의 풀이</strong> 🤔</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">participant, completion</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1️⃣</span></span><br><span class="line">  participant.sort();</span><br><span class="line">  completion.sort();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2️⃣</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; participant.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 3️⃣</span></span><br><span class="line">    <span class="keyword">if</span> (participant[i] !== completion[i]) <span class="keyword">return</span> participant[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1️⃣ participant와 completion 배열을 sort 함수를 통해 정렬시킨다.<br>2️⃣ particpant 배열의 길이만큼 <code>for</code>문을 순회한다.<br>3️⃣ 정렬 해주었기 때문에 순서대로 비교하며 다를 경우를 확인한다. participant 배열에 한명이 더 많기 때문에 다르다는 것은 participant 배열에 있는 사람이 완주하지 못한 선수라는 뜻이다.</p><hr><h2 id="다른-분의-풀이-👏"><a href="#다른-분의-풀이-👏" class="headerlink" title="다른 분의 풀이 👏"></a><strong>다른 분의 풀이</strong> 👏</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">participant, completion</span>) </span>&#123;</span><br><span class="line">  participant.sort();</span><br><span class="line">  completion.sort();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> participant) &#123;</span><br><span class="line">    <span class="keyword">if</span> (participant[i] !== completion[i]) <span class="keyword">return</span> participant[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉 차이점은 <code>for...in</code>문과 <code>for</code>문이다. 댓글에 보면 성능적인 차이가 있다고 한다. <code>for</code>문이 <code>for...in</code>문에 비해 좀 더 성능적으로 우수하다는 의견이 있다. 이 부분에 대해서는 좀 더 공부해보는걸로!</p><hr><h2 id="관련-학습-내용-🔎"><a href="#관련-학습-내용-🔎" class="headerlink" title="관련 학습 내용 🔎"></a><strong>관련 학습 내용</strong> 🔎</h2><p><a href="https://jimmyjoo.github.io/2020/09/14/js/Sort/">배열 정렬 메소드 sort()</a> 📚</p><p><a href="https://jimmyjoo.github.io">for문(성능)</a> 📚</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="algorithms" scheme="https://jimmyjoo.github.io/categories/algorithms/"/>
    
    
    <category term="algorithms" scheme="https://jimmyjoo.github.io/tags/algorithms/"/>
    
    <category term="programmers" scheme="https://jimmyjoo.github.io/tags/programmers/"/>
    
    <category term="hash" scheme="https://jimmyjoo.github.io/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>함수(Function)</title>
    <link href="https://jimmyjoo.github.io/2020/07/18/js/12.%20Function/"/>
    <id>https://jimmyjoo.github.io/2020/07/18/js/12.%20Function/</id>
    <published>2020-07-18T02:10:39.000Z</published>
    <updated>2020-09-16T07:54:58.603Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><!-- # **함수(Function)**  --><ul><li>일련의 과정을 문(statement)들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것</li><li><strong>매개변수(parameter)</strong>: 함수 정의할 때 내부로 입력을 전달받는 변수</li><li><strong>인수(argument)</strong>: 함수 호출될 때 내부로 입력받는 값</li><li><strong>반환 값(return value)</strong>: 함수가 출력하는 값</li><li><strong>함수 정의(function definition)</strong> 를 통해 함수를 생성</li><li><strong>함수 호출(function call/invoke)</strong> 을 통해 함수 실행</li><li>함수의 필요성: 재사용성 및 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과</li></ul><br><hr><br><h2 id="함수-리터럴"><a href="#함수-리터럴" class="headerlink" title="함수 리터럴"></a><strong>함수 리터럴</strong></h2><ul><li><strong>함수 이름</strong><ul><li>함수 이름은 식별자 -&gt; 네이밍 규칙 준수</li><li>함수 이름(식별자)은 함수 몸체 내에서만 참조 가능</li><li>함수 이름 생략 가능<ul><li>기명 함수(named function): 이름 O</li><li>익명 함수(anonymous function): 이름 X</li></ul></li></ul></li><li><strong>매개변수 목록</strong><ul><li>0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분</li><li>매개변수에는 함수호출문의 인수가 순서대로 할당(순서 의미 O)</li><li>매개변수는 함수 몸체 내에서 변수와 동일하게 취급 -&gt; 식별자 네이밍 규칙을 준수</li></ul></li><li><strong>함수 몸체</strong><ul><li>함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록</li><li>함수 몸체는 함수 호출에 의해 실행</li></ul></li></ul><br><hr><br><h2 id="함수-정의"><a href="#함수-정의" class="headerlink" title="함수 정의"></a><strong>함수 정의</strong></h2><ol><li><h3 id="함수-선언문-Function-declaration-statement"><a href="#함수-선언문-Function-declaration-statement" class="headerlink" title="함수 선언문(Function declaration/statement)"></a><strong>함수 선언문(Function declaration/statement)</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 참조</span></span><br><span class="line"><span class="comment">// console.dir은 console.log와는 달리 함수 객체의 프로퍼티까지 출력한다.</span></span><br><span class="line"><span class="comment">// 단, Node.js 환경에서는 console.log와 같은 결과가 출력된다.</span></span><br><span class="line"><span class="built_in">console</span>.dir(add); <span class="comment">// ƒ add(x, y)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><ul><li>함수 이름 생략 불가능</li><li>함수 선언문은 표현식이 아닌 문</li></ul><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없다.</span></span><br><span class="line"><span class="comment">// 하지만 함수 선언문이 변수에 할당되는 것처럼 보인다.</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><ul><li>자바스크립트 엔진이 상황에 따라 동일한 함수 리터럴을 표현식이 아닌 문인 함수 선언문으로 해석하는 경우와 표현식인 문인 함수 리터럴 표현식으로 해석하는 경우가 있음</li><li>하지만 내부 동작에 차이가 있음</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이름이 있는 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석한다.</span></span><br><span class="line"><span class="comment">// 함수 선언문은 함수 이름을 생략할 수 없다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식로 해석한다.</span></span><br><span class="line"><span class="comment">// 함수 리터럴은 함수 이름을 생략할 수 있다.</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">bar(); <span class="comment">// ReferenceError: bar is not defined</span></span><br></pre></td></tr></table></figure><ul><li>함수 선언문은 실행되어 함수 객체를 생성 -&gt; 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당</li><li>함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출</li><li>함수 이름과 변수 이름이 일치하므로 함수 이름으로 호출되는 듯 보이지만 사실은 식별자로 호출</li></ul></li></ol><br><ol start="2"><li><h3 id="함수-표현식-Function-expression"><a href="#함수-표현식-Function-expression" class="headerlink" title="함수 표현식(Function expression)"></a><strong>함수 표현식(Function expression)</strong></h3><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기명 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 객체를 가리키는 식별자로 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 이름으로 호출하면 ReferenceError가 발생한다.</span></span><br><span class="line"><span class="comment">// 함수 이름은 함수 몸체 내부에서만 유효한 식별자이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure></code></pre><br></li><li><h3 id="생성자-함수-Constructor-function"><a href="#생성자-함수-Constructor-function" class="headerlink" title="생성자 함수(Constructor function)"></a><strong>생성자 함수(Constructor function)</strong></h3><pre><code>- 자바스크립트가 기본 제공하는 빌트인 함수인 Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출하면 함수 객체를 생성하여 반환- Function 생성자 함수로 생성한 함수는 클로저를 생성하지 않는 등, 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add1 = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add1(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add2 = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'return x + y + a;'</span>);</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add2(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure></code></pre><br></li><li><h3 id="화살표-함수-Arrow-function"><a href="#화살표-함수-Arrow-function" class="headerlink" title="화살표 함수(Arrow function))"></a><strong>화살표 함수(Arrow function))</strong></h3><pre><code>- ES6에서 새롭게 도입- function 키워드 대신 화살표(=&gt;, Fat arrow)를 사용- 화살표 함수는 항상 익명 함수로 정의- 생성자 함수로 사용할 수 없으며 기존의 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 arguments 객체를 생성 X<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 화살표 함수</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></code></pre><br></li></ol><hr><h2 id="함수-생성-시점과-함수-호이스팅"><a href="#함수-생성-시점과-함수-호이스팅" class="headerlink" title="함수 생성 시점과 함수 호이스팅"></a><strong>함수 생성 시점과 함수 호이스팅</strong></h2><ul><li>함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다름</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 참조</span></span><br><span class="line"><span class="built_in">console</span>.dir(add); <span class="comment">// ƒ add(x, y)</span></span><br><span class="line"><span class="built_in">console</span>.dir(sub); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(sub(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// TypeError: sub is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> sub = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>함수 호이스팅(Function hoisting)</strong><ul><li>함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징</li><li><strong>함수 선언문</strong>으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성 -&gt; 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당</li><li>런타임에는 이미 함수 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당까지 완료된 상태 -&gt; 함수 선언문 이전에 함수를 참조할 수 있으며 호출 가능</li><li>변수 호이스팅? 함수 호이스팅?<ul><li>var 키워드로 사용한 변수 선언문과 함수 선언문은 모두 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 식별자를 생성한다는 점에서 동일</li><li>변수 호이스팅: var 키워드로 선언된 변수는 undefined로 초기화</li><li>함수 호이스팅: 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화</li><li>따라서 var 키워드로 사용한 변수 선언문 이전에 변수를 참조하면 변수 호이스팅에 의해 undefined로 평가되지만 함수 선언문으로 정의한 함수를 함수 선언문 이전에 호출하면 함수 호이스팅에 의해 호출이 가능</li></ul></li><li>변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 됨</li><li><strong>함수 표현식</strong>으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생</li><li>함수 표현식 이전에 함수를 참조하면 undefined으로 평가 -&gt; 이때 함수를 호출하면 undefined를 호출하는 것과 마찬가지이므로 타입 에러(TypeError)가 발생</li><li>즉, 함수 표현식으로 함수를 정의하였으면 함수 표현식 이후에 참조 및 호출</li></ul></li></ul><hr><h2 id="함수-호출-Function-call-invoke"><a href="#함수-호출-Function-call-invoke" class="headerlink" title="함수 호출(Function call/invoke)"></a><strong>함수 호출(Function call/invoke)</strong></h2><ul><li>함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 컨트롤을 넘김</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y); <span class="comment">// 2 5</span></span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="comment">// 인수 1과 2는 매개변수 x와 y에 순서대로 할당되고 함수 몸체의 문들이 실행된다.</span></span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><br><h3 id="매개변수와-인수"><a href="#매개변수와-인수" class="headerlink" title="매개변수와 인수"></a><strong>매개변수와 인수</strong></h3><ul><li>매개변수는 함수 몸체 내부에서만 참조 가능. (= 매개변수의 스코프는 함수 내부)</li><li>인수가 부족하여 인수가 할당되지 않은 매개변수의 값은 undefined</li><li>인수 &gt; 매개변수 -&gt; 초과되는 인수 무시(암묵적으로 argument 객체의 프로퍼티로 보관)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y); <span class="comment">// 2 5</span></span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 add의 매개변수 x, y는 함수 몸체 내부에서만 참조할 수 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log(x, y); <span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 인수 &lt; 매개변수 (2 + undefined = NaN)</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>)); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 인수 &gt; 매개변수</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><br><h3 id="인수-확인"><a href="#인수-확인" class="headerlink" title="인수 확인"></a><strong>인수 확인</strong></h3><ul><li>매개변수와 인수의 개수가 일치하는지 확인 X</li><li>매개변수의 타입을 사전에 지정할 수 없음</li><li>여러 방법을 통해 예외 처리</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 인수가 부족할 경우 NaN 결과값을 방지하기 위해 초기값(undefined -&gt; 0) 지정</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  a = a || <span class="number">0</span>;</span><br><span class="line">  b = b || <span class="number">0</span>;</span><br><span class="line">  c = c || <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(add()); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="반환문"><a href="#반환문" class="headerlink" title="반환문"></a><strong>반환문</strong></h3><ul><li><code>return</code>: 실행 결과를 함수 외부로 반환</li><li>함수의 실행을 중단하고 함수 몸체를 빠져나감 -&gt; 그 이후의 문은 실행 X</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y; <span class="comment">// 반환문</span></span><br><span class="line">  <span class="comment">// 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'실행되지 않는다.'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(multiply(<span class="number">3</span>, <span class="number">5</span>)); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><br><ul><li>return 키워드 뒤에 지정한 값을 반환(지정하지 않으면 undefined 반환)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// return 키워드 뒤에 반환값을 명시적으로 지정하지 않으면 undefined가 반환된다.</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 반환문을 생략하면 암묵적으로 undefined가 반환된다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo()); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(bar()); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><hr><h2 id="참조에-의한-전달과-외부-상태의-변경"><a href="#참조에-의한-전달과-외부-상태의-변경" class="headerlink" title="참조에 의한 전달과 외부 상태의 변경"></a><strong>참조에 의한 전달과 외부 상태의 변경</strong></h2><ul><li>매개변수에 원시타입이 들어올 경우:<ul><li>함수 내에서 원시값이 변경되어도 외부 원시타입에 영향 X</li></ul></li><li>매개변수에 객체타입가 들어올 경우:<ul><li>함수 내에서 객체가 변경되면 외부 객체에 영향</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 매개변수 primitive는 원시값을 전달받고, 매개변수 obj는 객체를 전달받는다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeVal</span>(<span class="params">primitive, obj</span>) </span>&#123;</span><br><span class="line">  primitive += <span class="number">100</span>;</span><br><span class="line">  obj.name = <span class="string">'Jimmy'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 외부 상태</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">'Joo'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "Joo"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달된다.</span></span><br><span class="line">changeVal(num, person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 원시 값은 원본이 훼손되지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체는 원본이 훼손된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "Jimmy"&#125;</span></span><br></pre></td></tr></table></figure><br><hr><h2 id="다양한-함수의-형태"><a href="#다양한-함수의-형태" class="headerlink" title="다양한 함수의 형태"></a><strong>다양한 함수의 형태</strong></h2><h3 id="1-즉시실행함수-IIFE-Immediately-Invoked-Function-Expression"><a href="#1-즉시실행함수-IIFE-Immediately-Invoked-Function-Expression" class="headerlink" title="1. 즉시실행함수(IIFE, Immediately Invoked Function Expression)"></a><strong>1. 즉시실행함수(IIFE, Immediately Invoked Function Expression)</strong></h3><ul><li>함수 정의와 동시에 즉시 호출되는 함수</li><li>단 한번만 호출되며 재호출 불가능</li><li>일반적으로 익명 함수</li><li>반드시 그룹 연산자(…)로 감싸주어야 함</li><li>사용하는 이유:<ol><li>인위적인 scope 생성</li><li>closure</li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 즉시 실행 함수에도 일반 함수처럼 인수를 전달할 수 있다.</span></span><br><span class="line">res = (<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;)(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 이런 방식으로도 사용가능. 화살표 함수와 같은 형태 -&gt; (...)그룹연산자로 감싸고 ( )호출</span></span><br><span class="line">res = (<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;)(<span class="number">3</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><br><h3 id="2-재귀함수-Recursive-function"><a href="#2-재귀함수-Recursive-function" class="headerlink" title="2. 재귀함수(Recursive function)"></a><strong>2. 재귀함수(Recursive function)</strong></h3><ul><li>자기 자신을 호출하는 함수</li><li>재귀 함수는 자신을 무한 재귀 호출 -&gt; 따라서 재귀 함수 내에는 재귀 호출을 멈출 수 있는 탈출 조건이 반드시 존재해야 함.</li><li>탈출 조건이 없는 경우, 함수가 무한 호출되어 stack overflow 에러가 발생</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 팩토리얼(계승)은 1부터 자신까지의 모든 양의 정수의 곱이다.</span></span><br><span class="line"><span class="comment">// n! = 1 * 2 * ... * (n-1) * n</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 탈출 조건: n이 1 이하일 때 재귀 호출을 멈춘다.</span></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 재귀 호출</span></span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">0</span>)); <span class="comment">// 0! = 1</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">1</span>)); <span class="comment">// 1! = 1</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">2</span>)); <span class="comment">// 2! = 2 * 1 = 2</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">3</span>)); <span class="comment">// 3! = 3 * 2 * 1 = 6</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">4</span>)); <span class="comment">// 4! = 4 * 3 * 1 * 1 = 24</span></span><br></pre></td></tr></table></figure><br><h3 id="3-중첩-함수-Nested-function"><a href="#3-중첩-함수-Nested-function" class="headerlink" title="3. 중첩 함수(Nested function)"></a><strong>3. 중첩 함수(Nested function)</strong></h3><ul><li><strong>중첩함수</strong>: 함수 내부에 정의된 함수 = 내부 함수(inner function)</li><li>중첩 함수를 포함하는 함수 = 외부 함수(outer function)</li><li>일반적으로 중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수(helper function)의 역할</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 중첩 함수</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 외부 함수의 변수를 참조할 수 있다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(x + y); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer();</span><br></pre></td></tr></table></figure><br><h3 id="4-콜백-함수-Callback-function"><a href="#4-콜백-함수-Callback-function" class="headerlink" title="4. 콜백 함수(Callback function)"></a><strong>4. 콜백 함수(Callback function)</strong></h3><ul><li>함수의 매개변수를 통해 전달되는 함수</li><li><strong>고차 함수(Higher-Order Function, HOF)</strong>: 콜백 함수를 매개변수를 통해 전달받은 함수</li><li>고차 함수는 콜백 함수를 자신의 일부분으로 합성</li><li>고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정하여 호출</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 외부에서 전달받은 f를 n만큼 반복 호출한다</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">n, f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// i를 전달하면서 f를 호출</span></span><br><span class="line">    f(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logAll = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반복 호출할 함수를 인수로 전달한다.</span></span><br><span class="line">repeat(<span class="number">5</span>, logAll); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logOdds = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반복 호출할 함수를 인수로 전달한다.</span></span><br><span class="line">repeat(<span class="number">5</span>, logOdds); <span class="comment">// 1 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열의 값에 value(10)를 곱함</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v * <span class="number">10</span>;</span><br><span class="line">&#125;); <span class="comment">// -&gt; [10, 20, 30, 40, 50]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열의 값에 value(2)를 곱함</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v * <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// -&gt; [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><br><h3 id="5-순수-비순수-함수-Pure-Impure-function"><a href="#5-순수-비순수-함수-Pure-Impure-function" class="headerlink" title="5. 순수/비순수 함수(Pure/Impure function)"></a><strong>5. 순수/비순수 함수(Pure/Impure function)</strong></h3><ul><li><strong>순수 함수</strong>: 부수효과 X</li><li><strong>비순수 함수</strong>: 부수효과 O</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>; <span class="comment">// 현재 카운트를 나타내는 상태</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 외부 상태에 의존하지 않으며 변경하지도 않는 순수 함수</span></span><br><span class="line"><span class="comment">// 순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 순수 함수가 반환한 결과값을 변수에 재할당하여 상태를 변경</span></span><br><span class="line">count = increase(count);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 함수의 외부 상태에 의존하여 외부 상태에 따라 반환값이 달라지는 비순수 함수</span></span><br><span class="line"><span class="comment">// 비순수 함수는 외부 상태를 변경하는 부수 효과(side effect)가 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++count; <span class="comment">// 외부 상태를 변경한다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다.</span></span><br><span class="line">increase();</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><br><hr><hr><br><p><strong>참고</strong> 👏</p><ul><li><a href="https://poiemaweb.com/js-function">PoiemaWeb - 함수</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/tags/javascript/"/>
    
    <category term="poiemaweb" scheme="https://jimmyjoo.github.io/tags/poiemaweb/"/>
    
    <category term="function" scheme="https://jimmyjoo.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>원시 값과 객체의 비교</title>
    <link href="https://jimmyjoo.github.io/2020/07/15/js/11.%20TypeComparison/"/>
    <id>https://jimmyjoo.github.io/2020/07/15/js/11.%20TypeComparison/</id>
    <published>2020-07-15T08:10:39.000Z</published>
    <updated>2020-09-16T07:54:35.240Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><!-- # **원시 값과 객체의 비교**  --><table><thead><tr><th></th><th><strong>원시타입</strong></th><th><strong>객체타입</strong></th></tr></thead><tbody><tr><td>값 변경여부</td><td>변경 불가능</td><td>변경 가능</td></tr><tr><td>저장되는 값</td><td>실제 값 저장</td><td>참조 값 저장</td></tr><tr><td>전달방식</td><td>값에 의한 전달(Pass by Value)</td><td>참조에 의한 전달(Pass by Reference)</td></tr></tbody></table><hr><br><br><h2 id="값-변경-여부"><a href="#값-변경-여부" class="headerlink" title="값 변경 여부"></a><strong>값 변경 여부</strong></h2><p><code>원시타입</code>은 <strong>변경 불가능</strong><br><code>객체타입</code>은 <strong>변경 가능</strong></p><p>여기서 말하는 “변경 불가능”이 어떤 뜻일까?</p><p>변경이 불가능하다는 뜻은 <strong>메모리 영역에서의 변경이 불가능</strong>하다는 뜻이다.<br>(재할당이랑 헷갈리지 말자).</p><ul><li><p><strong>변경 불가능 한 값(immutable)</strong></p><ul><li>변수 값은 변경 가능: 재할당에 의해서</li><li>값 자체는 변경 불가능(read-only)</li></ul></li><li><p><strong>문자열과 불변성</strong></p><ul><li>자바스크립트에서 문자열은 원시타입 -&gt; 변경 불가능</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'Hello'</span>;</span><br><span class="line"></span><br><span class="line">str = <span class="string">'world!'</span>; <span class="comment">// 새로운 메모리 공간 확보 -&gt; 식별자 str는 'world!'를 가르킴</span></span><br><span class="line"></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'S'</span>; <span class="comment">// 원시값이기 때문에 변하지 않음. 에러발생 X</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// -&gt; 'world!'</span></span><br></pre></td></tr></table></figure></li><li><p><strong>값에 의한 전달(Pass by Value)</strong></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수 copy에는 변수 score의 값 80이 복사되어 할당된다.</span></span><br><span class="line"><span class="keyword">var</span> copy = score;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(score, copy); <span class="comment">// 80  80</span></span><br><span class="line"><span class="built_in">console</span>.log(score === copy); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수 score와 변수 copy의 값은 다른 메모리 공간에 저장된 별개의 값이다.</span></span><br><span class="line"><span class="comment">// 따라서 변수 score의 값을 변경하여도 변수 copy의 값에는 어떠한 영향도 주지 않는다.</span></span><br><span class="line">score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(score, copy); <span class="comment">// 100  80</span></span><br><span class="line"><span class="built_in">console</span>.log(score === copy); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><hr><h2 id="객체"><a href="#객체" class="headerlink" title="객체"></a><strong>객체</strong></h2><ul><li><p>프로퍼티 동적 추가/삭제 가능</p></li><li><p><strong>변경 가능 한 값(mutable)</strong></p><ul><li>재할당 없이 객체를 직접 변경 가능</li><li>얕은 복사(shallow copy)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 값 갱신</span></span><br><span class="line">person.name = <span class="string">'Kim'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 동적 생성</span></span><br><span class="line">person.address = <span class="string">'Seoul'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "Kim", address: "Seoul"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newPerson = person; <span class="comment">// shallow copy</span></span><br></pre></td></tr></table></figure></li><li><p><strong>참조에 의한 전달(Pass by Reference)</strong></p><ul><li>객체를 가르키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달</li><li>이렇게 될 경우, 두 변수 모두 같은 주소값을 가르킴</li><li>둘 중 한 객체가 변경될 경우, 다른 객체도 영향을 받음</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Jimmy'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 참조 값을 복사. copy와 person은 동일한 참조 값을 갖는다.</span></span><br><span class="line"><span class="keyword">var</span> copy = person;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy와 person은 동일한 객체를 참조한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(copy === person); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// copy를 통해 객체를 변경한다.</span></span><br><span class="line">copy.name = <span class="string">'Joo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person을 통해 객체를 변경한다.</span></span><br><span class="line">person.address = <span class="string">'Seoul'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy와 person은 동일한 객체를 가리키고 있다.</span></span><br><span class="line"><span class="comment">// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "Joo", address: "Seoul"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// &#123;name: "Joo", address: "Seoul"&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><hr><br><p><strong>참고</strong> 👏</p><ul><li><a href="https://poiemaweb.com/js-object">PoiemaWeb - 객체</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/tags/javascript/"/>
    
    <category term="data type" scheme="https://jimmyjoo.github.io/tags/data-type/"/>
    
    <category term="pass-by-value" scheme="https://jimmyjoo.github.io/tags/pass-by-value/"/>
    
    <category term="pass-by-reference" scheme="https://jimmyjoo.github.io/tags/pass-by-reference/"/>
    
    <category term="poiemaweb" scheme="https://jimmyjoo.github.io/tags/poiemaweb/"/>
    
  </entry>
  
  <entry>
    <title>객체 리터럴(Object Literal)</title>
    <link href="https://jimmyjoo.github.io/2020/07/12/js/10.%20ObjectLiteral/"/>
    <id>https://jimmyjoo.github.io/2020/07/12/js/10.%20ObjectLiteral/</id>
    <published>2020-07-12T14:31:18.000Z</published>
    <updated>2020-09-16T07:52:47.948Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h2 id="객체-Object-📍"><a href="#객체-Object-📍" class="headerlink" title="객체(Object)📍"></a><strong>객체</strong>(Object)📍</h2><p>자바스크립트에서는 원시 값을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 <code>객체</code>이다.</p><p><code>객체</code>란 <strong>데이터(property)</strong>와 그 <strong>데이터에 관련한 동작(method)</strong>을 모두 포함할 수 있는 독립적 주체이다.</p><p><strong>프로퍼티</strong>란 객체의 상태를 나타내는 값이다.<br><strong>메소드</strong>란 프로퍼티를 참조하고 조작할 수 있는 동작이다.</p><br><p>😫 이것도 객체..? 저것도 객체..??</p><p>자바스크립트를 공부하다보면 객체란 단어를 자주 접하게 된다.<br>하지만 객체에 대한 개념을 정확하게 파악하지 못하면 오히려 더욱 헷갈리게 만든다.</p><p>먼저, 우리가 “자바스크립트에서는 원시 값을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다.” 라고 표현할 때 <code>객체</code>란 참조값을 저장하고, 참조에 의한 전달방식을 사용하고, 변경이 가능한(mutable) 객체/참조 타입을 의미하는 포괄적인 용어이다.</p><p>우리는 때론 <strong>객체 리터럴</strong>을 간편하게 <code>객체</code>라고 부를때도 있다. 여기서 말하는 <code>객체</code>란 중괄호를 사용해 값을 생성하는 방식인 <strong>객체 리터럴</strong>만을 의미한다.</p><hr><h2 id="객체-리터럴에-의한-객체-생성📍"><a href="#객체-리터럴에-의한-객체-생성📍" class="headerlink" title="객체 리터럴에 의한 객체 생성📍"></a><strong>객체 리터럴에 의한 객체 생성</strong>📍</h2><p>C++과 Java 같은 <strong>클래스 기반</strong> 객체지향 언어는 클래스를 사전에 정의하고 new 연산자와 함께 생성자(constructor)를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성한다.</p><p>자바스크립트에서는 <strong>프로토타입 기반</strong> 객체지향 언어로서 다양한 객체 생성 방법이 존재한다. 그 중에는 객체 리터럴, <code>Object</code> 생성자 함수, 생성자 함수, <code>Object.create</code> 메소드, 클래스가 있다.</p><p>오늘은 그 중에서 가장 일반적이고 간단한 <strong>객체 리터럴</strong> 방법에 대해서 알아보자.</p><p>복습을 해보자면 <strong>리터럴</strong>은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법이다.</p><p><strong>객체 리터럴</strong>은 <strong>중괄호(<code>{...}</code>) 내에 0개 이상의 프로퍼티를 정의</strong>하여 값을 생성하는 표기법이다.</p><p>변수에 할당이 이루어지는 시점에 JS엔진이 객체 리터럴을 해석하여 객체를 생성한다.</p><p><strong>주의할점</strong>❗️<br>객체 리터럴의 중괄호(<code>{}</code>)는 코드 블록 의미하지 않는다. 코드 블록의 닫는 중괄호 뒤에는 세미콜론(<code>;</code>)이 오지 않는다. 하지만, 객체 리터럴은 값으로 평가되는 표현식이다. 따라서, 닫는 중괄호 뒤에 세미콜론을 붙인다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체 생성</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Joo'</span>; <span class="comment">// 프로퍼티</span></span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 메소드</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 빈 객체 생성</span></span><br><span class="line"><span class="keyword">var</span> emptyObject = &#123;&#125;;</span><br></pre></td></tr></table></figure><br><hr><h2 id="프로퍼티-Property-📍"><a href="#프로퍼티-Property-📍" class="headerlink" title="프로퍼티(Property)📍"></a><strong>프로퍼티(Property)</strong>📍</h2><p><strong>프로퍼티</strong>란 객체의 상태를 나타내는 값(데이터)이며 <strong>키(key)</strong>과 <strong>값(value)</strong>으로 구성되어있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  myKey1: <span class="string">'myValue1'</span>,</span><br><span class="line">  <span class="string">'my-key2'</span>: <span class="string">'myValue2'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="number">10</span>,</span><br><span class="line">  myKey1: <span class="string">'myValue3'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>프로퍼티를 나열할 때 쉼표(<code>,</code>)로 구분한다.<br>(마지막 프로퍼티 뒤에는 쉼표는 옵션)</p><p><strong>프로퍼티 키</strong><br>빈 문자열을 포함하는 모든 문자열 또는 symbol값이 올 수 있다.<br>프로퍼티 키가 <strong>식별자 네이밍 규칙</strong> 따르면 따옴표(<code>&#39;&#39;</code>) 생략 가능하지만 따르지 않으면 따옴표를 반드시 붙혀야한다.<br>프로퍼티 키의 이름이 같은 경우 나중에 실행된 프로퍼티가 덮어쓴다.</p><p>만약 프로퍼티 키가 숫자라면 따옴표는 붙지 않지만 내부적으로는 문자열로 변환된다. 따라서 정확히 말하면 숫자가 아니라 문자열이다.</p><br><p><strong>프로퍼티 값</strong><br>자바스크립트에서 사용할 수 있는 모든 값이 올 수 있다.<br><code>number</code>, <code>string</code>, <code>boolean</code> 같은 원시타입은 물론 함수나 배열 같은 객체타입도 올 수 있다. 객체리터럴(<code>{}</code> 또한 가능하다.</p><br><hr><h3 id="프로퍼티-접근"><a href="#프로퍼티-접근" class="headerlink" title="프로퍼티 접근"></a><strong>프로퍼티 접근</strong></h3><p>프로퍼티 접근 방법은 2가지가 있다.</p><p>1️⃣<strong>마침표 표기법</strong>(<code>.</code>)<br>2️⃣<strong>대괄호 표기법</strong>(<code>[]</code>)</p><p><strong>대괄호 표기법</strong>은 대괄호 안에 반드시 따옴표로 감싼 문자열이 와야한다. 감싸지 않으면 식별자로 해석되기 때문이다.</p><p>프로퍼티 키가 <strong>식별자 네이밍 규칙</strong>을 따르는 마침표 표기법, 대괄표 표기법 둘 다 사용가능하나 따르지 않을 경우 대괄표 표기법만 가능하다.</p><p>객체에 존재하지 않는 프로퍼티에 접근하면 <code>undefined</code>를 반환한다.</p><p>프로퍼티 키가 숫자로 이루어진 문자열인 경우, 따옴표를 생략 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Joo'</span>;</span><br><span class="line">  <span class="string">'first-name'</span>: <span class="string">'Jimmy'</span>;</span><br><span class="line">  <span class="number">10</span>: <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 마침표 표기법에 의한 프로퍼티 접근</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Joo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 대괄호 표기법에 의한 프로퍼티 접근</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'name'</span>]); <span class="comment">// Joo</span></span><br><span class="line"><span class="built_in">console</span>.log(person[name]); <span class="comment">// ReferenceError: name is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 존재하지 않는 프로퍼티 접근</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 키가 유효하지 않은 이름일 경우 -&gt; 대괄호 사용!</span></span><br><span class="line"><span class="built_in">console</span>.log(person.<span class="string">'first-name'</span>); <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="built_in">console</span>.log(person[first-name]); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'first-name'</span>]); <span class="comment">// Jimmy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//프로퍼티 키가 숫자로 이루어진 문자열일 경우</span></span><br><span class="line"><span class="built_in">console</span>.log(person<span class="number">.10</span>); <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="built_in">console</span>.log(person.<span class="string">'10'</span>); <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="number">10</span>]); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'10'</span>]); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><br><h3 id="프로퍼티-값-갱신-생성-삭제"><a href="#프로퍼티-값-갱신-생성-삭제" class="headerlink" title="프로퍼티 값 갱신/생성/삭제"></a><strong>프로퍼티 값 갱신/생성/삭제</strong></h3><p>프로퍼티 값은 동적으로 갱신, 생성, 삭제가 가능하다.</p><p>이미 존재하는 프로퍼티에 값에 할당하면 프로퍼티 값이 갱신된다.</p><p>만약 존재하지 않는 프로퍼티에 값을 할당하면?? 🧐</p><p>새롭게 생성된다.</p><p>프로퍼티 삭제는 <code>delete</code> 연산자를 사용하자.<br>없는 프로퍼티를 삭제해도 에러가 발생하지 않는다. 아무런 일도 발생하지 않는다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Jimmy'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// name 값 갱신</span></span><br><span class="line">person.name = <span class="string">'Joo'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Joo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 생성(해당 프로퍼티 존재하지 않을경우 생성, 존재할 경우 갱신)</span></span><br><span class="line">person.age = <span class="number">27</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person); &#123;<span class="attr">name</span>: <span class="string">'Joo'</span>, <span class="attr">age</span>: <span class="number">27</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 존재하는 프로퍼티 삭제, 존재하지 않을 경우 무시(에러X)</span></span><br><span class="line"><span class="keyword">delete</span> person.age;</span><br><span class="line"><span class="keyword">delete</span> person.height; <span class="comment">// 무시됨</span></span><br></pre></td></tr></table></figure><br><hr><h2 id="메소드-Method-📍"><a href="#메소드-Method-📍" class="headerlink" title="메소드(Method)📍"></a><strong>메소드(Method)</strong>📍</h2><p>자바스크립트에서 모든 값은 프로퍼티의 값이 될 수 있다.<br>자바스크립트의 함수는 일급 객체이므로 값이다.<br>따라서, 함수 또한 프로퍼티의 값이 될 수 있다.<br>객체의 프로퍼티의 값이 함수인 경우 <strong>메소드</strong>라 말한다.</p><p>즉, <strong>메소드</strong>란 객체에 제한되어 있는 함수이다.<br><strong>메소드</strong>란 <strong>객체의 프로퍼티를 참조하거나 조작하는 함수</strong>에 한정지어 정의하는 것이 더 구체적일것이다.</p><p>(객체의 프로퍼티를 조작하지 않는 함수의 경우 메소드라 부르기보단 차라리 프로퍼티 값이 일반함수라고 말하는게 오해의 소지가 없을수도 있다고 생각한다.)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Joo'</span>;</span><br><span class="line">  sayName(): <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 메소드</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi! My name is '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="ES6에서-추가된-객체-리터럴의-확장-기능📍"><a href="#ES6에서-추가된-객체-리터럴의-확장-기능📍" class="headerlink" title="ES6에서 추가된 객체 리터럴의 확장 기능📍"></a><strong>ES6에서 추가된 객체 리터럴의 확장 기능</strong>📍</h2><p>1️⃣<strong>프로퍼티 축약 표현</strong><br>프로퍼티 값으로 변수를 사용하는 경우, 변수 이름과 프로퍼티 키가 동일한 이름일 때, 프로퍼티 키를 생략 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = <span class="string">'Jimmy'</span>;</span><br><span class="line"><span class="keyword">const</span> lastName = <span class="string">'Joo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; firstName, lastName &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;firstName: 'Jimmy', lastName: 'Joo'&#125;</span></span><br></pre></td></tr></table></figure><br><p>2️⃣<strong>프로퍼티 키 동적 생성</strong><br>객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성 가능하다. (그 전에는 외부에서만 가능했다.)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> prefix = <span class="string">'prop'</span>;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="string">`<span class="subst">$&#123;prefix&#125;</span>-<span class="subst">$&#123;++i&#125;</span>`</span>]: i,</span><br><span class="line">  [<span class="string">`<span class="subst">$&#123;prefix&#125;</span>-<span class="subst">$&#123;++i&#125;</span>`</span>]: i,</span><br><span class="line">  [<span class="string">`<span class="subst">$&#123;prefix&#125;</span>-<span class="subst">$&#123;++i&#125;</span>`</span>]: i,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;prop-1: 1, prop-2: 2, prop-3: 3&#125;</span></span><br></pre></td></tr></table></figure><br><p>3️⃣<strong>메소드 축약 표현</strong><br>메소드 정의할 때, <code>function</code> 키워드를 생략 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Jimmy'</span>,</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.sayHi(); <span class="comment">//Hi! My name is Jimmy</span></span><br></pre></td></tr></table></figure><br><hr><hr><br><p><strong>참고</strong> 👏</p><ul><li><a href="https://poiemaweb.com/js-object">PoiemaWeb - 객체</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/tags/javascript/"/>
    
    <category term="object" scheme="https://jimmyjoo.github.io/tags/object/"/>
    
    <category term="property" scheme="https://jimmyjoo.github.io/tags/property/"/>
    
    <category term="method" scheme="https://jimmyjoo.github.io/tags/method/"/>
    
    <category term="ES6" scheme="https://jimmyjoo.github.io/tags/ES6/"/>
    
    <category term="poiemaweb" scheme="https://jimmyjoo.github.io/tags/poiemaweb/"/>
    
  </entry>
  
  <entry>
    <title>타입 변환과 단축 평가(Type Conversion)</title>
    <link href="https://jimmyjoo.github.io/2020/07/11/js/9.%20TypeConversion/"/>
    <id>https://jimmyjoo.github.io/2020/07/11/js/9.%20TypeConversion/</id>
    <published>2020-07-11T12:10:09.000Z</published>
    <updated>2020-09-16T07:52:24.971Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><ul><li><strong>명시적 타입 변환(Explicit coercion)</strong></li><li><strong>암묵적 타입 변환(Implicit coercion)</strong></li><li>기존 원시값을 직접 변경 X,(원시값은 변경 불가능이기 때문)</li><li>새로운 원시값 생성.</li><li>암묵적 타입 변환 같은 경우,</li></ul><hr><h2 id="암묵적-타입-변환-Implicit-Coercion"><a href="#암묵적-타입-변환-Implicit-Coercion" class="headerlink" title="암묵적 타입 변환(Implicit Coercion)"></a><strong>암묵적 타입 변환</strong>(Implicit Coercion)</h2><ul><li><strong>타입 강제 변환(Type coercion)</strong></li><li>표현식을 평가하는 도중에 JS엔진에 의해 암묵적으로 타입이 변환</li><li>새로운 값을 만들었다가 한번 사용하고 표현식의 평가가 끝나면 가비지 컬렉터에 의해서 메모리에서 해제</li></ul><h3 id="문자열-타입으로-변환"><a href="#문자열-타입으로-변환" class="headerlink" title="문자열 타입으로 변환"></a><strong>문자열 타입으로 변환</strong></h3><ul><li><strong>+ 연산자</strong></li><li>피연산자 중 하나 이상이 문자열일 경우 문자열 연결 연산자로 동작</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">'2'</span>; <span class="comment">// "12"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`1 + 1 = <span class="subst">$&#123;<span class="number">1</span> + <span class="number">1</span>&#125;</span>`</span>); <span class="comment">// 1 + 1 = 2</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> + <span class="string">''</span>; <span class="comment">// "0"</span></span><br><span class="line"><span class="literal">false</span> + <span class="string">''</span>; <span class="comment">// "false"</span></span><br><span class="line"><span class="literal">null</span> + <span class="string">''</span>; <span class="comment">// "null"</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="string">''</span>; <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Symbol</span>() + <span class="string">''</span>; <span class="comment">// TypeError</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; + <span class="string">''</span>); <span class="comment">// "function()&#123;&#125;"</span></span><br></pre></td></tr></table></figure><br><h3 id="숫자-타입으로-변환"><a href="#숫자-타입으로-변환" class="headerlink" title="숫자 타입으로 변환"></a><strong>숫자 타입으로 변환</strong></h3><ul><li>JS엔진이 산술 연산자나 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환</li><li>피연산자를 숫자로 변경할 수 없는 경우 평가결과 NaN</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> - <span class="string">'1'</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="number">1</span> * <span class="string">'10'</span>; <span class="comment">// 10</span></span><br><span class="line"><span class="number">1</span> / <span class="string">'one'</span> + <span class="comment">// NaN</span></span><br><span class="line">  <span class="string">''</span> + <span class="comment">// 0</span></span><br><span class="line">  <span class="string">'0'</span> + <span class="comment">// 0</span></span><br><span class="line">  <span class="string">'1'</span> + <span class="comment">// 1</span></span><br><span class="line">  <span class="string">'String'</span> + <span class="comment">// NaN</span></span><br><span class="line">  <span class="literal">null</span> + <span class="comment">// 1</span></span><br><span class="line">  <span class="literal">undefined</span> + <span class="comment">// NaN</span></span><br><span class="line">  <span class="built_in">Symbol</span>() + <span class="comment">// TypeError</span></span><br><span class="line">  [] + <span class="comment">// 0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure><br><h3 id="불리언-타입으로-변환"><a href="#불리언-타입으로-변환" class="headerlink" title="불리언 타입으로 변환"></a><strong>불리언 타입으로 변환</strong></h3><ul><li>JS엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환시킴</li><li>불리언 타입이 아닌 값을 <strong>Truthy 값</strong>(참으로 평가되는 값) 또는 <strong>Falsy 값</strong>(거짓으로 평가되는 값)으로 구분</li><li><strong>Falsy값</strong><ul><li><code>false</code></li><li><code>undefined</code></li><li><code>null</code></li><li><code>0, -0</code></li><li><code>NaN</code></li><li><code>&#39;&#39;</code>(빈 문자열)</li></ul></li><li><strong>Truthy값</strong>: Falsy 값 이외의 모든 값</li></ul><br><hr><h2 id="명시적-타입-변환-Explicit-Coercion"><a href="#명시적-타입-변환-Explicit-Coercion" class="headerlink" title="명시적 타입 변환(Explicit Coercion)"></a><strong>명시적 타입 변환</strong>(Explicit Coercion)</h2><ul><li><strong>타입 캐스팅(Type casting)</strong></li><li>개발자가 의도적으로 값의 타입을 변환</li></ul><h3 id="문자열-타입으로-변환-1"><a href="#문자열-타입으로-변환-1" class="headerlink" title="문자열 타입으로 변환"></a><strong>문자열 타입으로 변환</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="number">1</span>)); <span class="comment">// "1"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">NaN</span>)); <span class="comment">// "NaN"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">true</span>)); <span class="comment">// "true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Object.prototype.toString 메소드를 사용하는 방법</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">1</span>).toString()); <span class="comment">// "1"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>.toString()); <span class="comment">// "NaN"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span>.toString()); <span class="comment">// "true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 문자열 연결 연산자를 이용하는 방법</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + <span class="string">''</span>); <span class="comment">// "1"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> + <span class="string">''</span>); <span class="comment">// "NaN"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> + <span class="string">''</span>); <span class="comment">// "true"</span></span><br></pre></td></tr></table></figure><br><h3 id="숫자-타입으로-변환-1"><a href="#숫자-타입으로-변환-1" class="headerlink" title="숫자 타입으로 변환"></a><strong>숫자 타입으로 변환</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">'10.53'</span>)); <span class="comment">// 10.53</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">false</span>)); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">'10.53'</span>)); <span class="comment">// 10.53</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. + 단항 산술 연산자를 이용하는 방법</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">'10.53'</span>); <span class="comment">// 10.53</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="literal">false</span>); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. * 산술 연산자를 이용하는 방법</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'10.53'</span> * <span class="number">1</span>); <span class="comment">// 10.53</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> * <span class="number">1</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><br><h3 id="불리언-타입으로-변환-1"><a href="#불리언-타입으로-변환-1" class="headerlink" title="불리언 타입으로 변환"></a><strong>불리언 타입으로 변환</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">''</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">'false'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">NaN</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">Infinity</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">null</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">undefined</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>([])); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. ! 부정 논리 연산자를 두번 사용하는 방법</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="string">''</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="string">'false'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">Infinity</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">null</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">undefined</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!![]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><br><hr><h2 id="단축-평가-Short-Circuit-Evaluation"><a href="#단축-평가-Short-Circuit-Evaluation" class="headerlink" title="단축 평가(Short-Circuit Evaluation)"></a><strong>단축 평가(Short-Circuit Evaluation)</strong></h2><ul><li>논리합(<code>||</code>) 연산자와 논리곱(<code>&amp;&amp;</code>) 연산자 표현식의 결과는 불리언 값이 아닐 수도 있음</li><li>논리합(<code>||</code>), 논리곱(<code>&amp;&amp;</code>) 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가됨</li><li><strong>단축평가</strong><ul><li>논리 연산의 결과를 결정한 타입 변환하지 않고 피연산자를 그대로 반환</li><li>표현식을 평가하는 도중에 평가 결과가 확정된 경우, 나머지 평가 과정을 중단</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 논리합(||) 연산자</span></span><br><span class="line"><span class="string">'Cat'</span> || <span class="string">'Dog'</span>; <span class="comment">// 'Cat'</span></span><br><span class="line"><span class="literal">false</span> || <span class="string">'Dog'</span>; <span class="comment">// 'Dog'</span></span><br><span class="line"><span class="string">'Cat'</span> || <span class="literal">false</span>; <span class="comment">// 'Cat'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 논리곱(&amp;&amp;) 연산자</span></span><br><span class="line"><span class="string">'Cat'</span> &amp;&amp; <span class="string">'Dog'</span>; <span class="comment">// Dog</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="string">'Dog'</span>; <span class="comment">// false</span></span><br><span class="line"><span class="string">'Cat'</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 논리곱(&amp;&amp;) 연산자 활용해 if문 대체 가능</span></span><br><span class="line"><span class="keyword">var</span> done = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 주어진 조건이 true일 때</span></span><br><span class="line"><span class="keyword">if</span> (done) message = <span class="string">'완료'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if문은 단축 평가로 대체 가능하다.</span></span><br><span class="line">message = done &amp;&amp; <span class="string">'완료'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// 완료</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체가 null인지 확인하고 프로퍼티를 참조할 때</span></span><br><span class="line"><span class="keyword">var</span> elem = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(elem.value); <span class="comment">// TypeError: Cannot read property 'value' of null</span></span><br><span class="line"><span class="built_in">console</span>.log(elem &amp;&amp; elem.value); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 매개변수에 기본값을 설정할 때</span></span><br><span class="line"><span class="comment">// 단축 평가를 사용한 매개변수의 기본값 설정</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStringLength</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">return</span> str.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStringLength(); <span class="comment">// 0</span></span><br><span class="line">getStringLength(<span class="string">'hi'</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6의 매개변수의 기본값 설정</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStringLength</span>(<span class="params">str = <span class="string">''</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStringLength(); <span class="comment">// 0</span></span><br><span class="line">getStringLength(<span class="string">'hi'</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><hr><hr><br><p><strong>참고</strong> 👏</p><ul><li><a href="https://poiemaweb.com/js-type-coercion">PoiemaWeb - 타입 변환과 단축 평가</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/tags/javascript/"/>
    
    <category term="type conversion" scheme="https://jimmyjoo.github.io/tags/type-conversion/"/>
    
    <category term="poiemaweb" scheme="https://jimmyjoo.github.io/tags/poiemaweb/"/>
    
  </entry>
  
  <entry>
    <title>제어문(Control Flow Statement)</title>
    <link href="https://jimmyjoo.github.io/2020/07/09/js/8.%20ControlFlowStatement/"/>
    <id>https://jimmyjoo.github.io/2020/07/09/js/8.%20ControlFlowStatement/</id>
    <published>2020-07-09T13:15:49.000Z</published>
    <updated>2020-09-23T01:23:14.561Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p><strong>제어문</strong>은 <strong>주어진 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용</strong>한다.</p><p>일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다. 하지만 제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.</p><hr><h2 id="블록문-Block-Compound-Statement-📍"><a href="#블록문-Block-Compound-Statement-📍" class="headerlink" title="블록문(Block/Compound Statement) 📍"></a><strong>블록문</strong>(Block/Compound Statement) 📍</h2><p><strong>블록문</strong>은 <strong>0개 이상의 문을 중괄호로 묶은 것으로 코드 블록</strong>이라고 부르기도 한다.<br>자바스크립트는 블록문을 하나의 실행 단위로 취급한다.</p><p>❗️문의 끝에는 세미 콜론(;)을 붙이는 것이 일반적이지만 블록문의 끝에는 세미콜론을 붙이지 않는다.</p><p>블록문은 단독으로 사용할 수 있으나 일반적으로 제어문이나 함수를 정의할 때 사용한다.</p><p>블록문이 사용되는 예시를 살펴보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 블록문(단독으로도 사용)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제어문</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  x++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><hr><h2 id="조건문-Conditional-Statement-📍"><a href="#조건문-Conditional-Statement-📍" class="headerlink" title="조건문(Conditional Statement) 📍"></a><strong>조건문</strong>(Conditional Statement) 📍</h2><p><strong>조건문</strong>은 <strong>주어진 조건식(conditional expression)의 평가 결과에 따라 코드 블럭(블록문)의 실행을 결정</strong>한다.</p><p>이때 조건식은 불리언 값으로 평가될 수 있는 표현식이다.</p><p>코드 블록 내의 문이 하나뿐이라면 중괄호를 생략 가능하다.</p><p>조건문의 종류에는 크게 <code>if...else</code>문, <code>switch</code>문이 있다.</p><p>아래 예시를 통해 살펴보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> kind;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if 문</span></span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  kind = <span class="string">'양수'</span>; <span class="comment">// 음수를 구별할 수 없다</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(kind); <span class="comment">// 양수</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if…else 문</span></span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  kind = <span class="string">'양수'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  kind = <span class="string">'음수'</span>; <span class="comment">// 0은 음수가 아니다.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(kind); <span class="comment">// 양수</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if…else if 문</span></span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  kind = <span class="string">'양수'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  kind = <span class="string">'음수'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  kind = <span class="string">'영'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(kind); <span class="comment">// 양수</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//삼항 조건 연산자 사용</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0은 false로 취급된다.</span></span><br><span class="line"><span class="keyword">var</span> kind = num ? (num &gt; <span class="number">0</span> ? <span class="string">'양수'</span> : <span class="string">'음수'</span>) : <span class="string">'영'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(kind); <span class="comment">// 양수</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//switch문</span></span><br><span class="line"><span class="keyword">var</span> year = <span class="number">2000</span>; <span class="comment">// 2000년은 윤년으로 2월이 29일이다.</span></span><br><span class="line"><span class="keyword">var</span> month = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> days = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (month) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">    days = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">    days = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">// 윤년 계산 알고리즘</span></span><br><span class="line">    <span class="comment">// 1. 년도가 4로 나누어 떨어지는 해는 윤년(2000, 2004, 2008, 2012, 2016, 2020…)</span></span><br><span class="line">    <span class="comment">// 2. 그 중에서 년도가 100으로 나누어 떨어지는 해는 평년(2000, 2100, 2200...)</span></span><br><span class="line">    <span class="comment">// 3. 그 중에서 년도가 400으로 나누어 떨어지는 해는 윤년(2000, 2400, 2800...)</span></span><br><span class="line">    days = (year % <span class="number">4</span> === <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> !== <span class="number">0</span>) || year % <span class="number">400</span> === <span class="number">0</span> ? <span class="number">29</span> : <span class="number">28</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Invalid month'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(days); <span class="comment">// 29</span></span><br></pre></td></tr></table></figure><hr><h2 id="반복문-Loop-Statement"><a href="#반복문-Loop-Statement" class="headerlink" title="반복문(Loop Statement)"></a><strong>반복문</strong>(Loop Statement)</h2><p><strong>반복문</strong>은 <strong>주어진 조건식의 평가 결과가 참인 경우 코드 블럭을 실행</strong>한다.<br>그 후 조건식을 다시 검사하여 여전히 참인 경우 코드 블록을 다시 실행한다. 이는 조건식이 거짓일 때까지 반복한다.</p><p>반복문의 종류에는 <code>for</code>문, <code>while</code>문, <code>do...while</code>문이 있다. (그 외에도 <code>for...in</code>문과 <code>for..of</code>문이 있지만 여기서는 앞에 3가지 반복문만 살펴보자)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 중첩 for문</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= <span class="number">6</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i + j === <span class="number">6</span>) <span class="built_in">console</span>.log(<span class="string">`[<span class="subst">$&#123;i&#125;</span>, <span class="subst">$&#123;j&#125;</span>]`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while문</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.</span></span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count);</span><br><span class="line">  count++;</span><br><span class="line">&#125; <span class="comment">// 0 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// do...while문 (최소 한번 실행)</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count);</span><br><span class="line">  count++;</span><br><span class="line">&#125; <span class="keyword">while</span> (count &lt; <span class="number">3</span>); <span class="comment">// 0 1 2</span></span><br></pre></td></tr></table></figure><hr><h2 id="break문-Break-Statement"><a href="#break문-Break-Statement" class="headerlink" title="break문(Break Statement)"></a><strong>break문</strong>(Break Statement)</h2><p><strong>break</strong>문은 <strong>레이블 문, 반복문(for, for…in, for…of, while, do…while) 또는 switch 문의 코드 블록을 탈출</strong>한다.</p><p>❗️레이블 문, 반복문, switch문의 코드 블록 이외에 break 문을 사용하면 <code>SyntaxError</code>(문법에러)가 발생한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">break</span>; <span class="comment">// Uncaught SyntaxError: Illegal break statement</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// outer라는 식별자가 붙은 레이블 for 문</span></span><br><span class="line">outer: <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">    <span class="comment">// i + j === 3이면 outer라는 식별자가 붙은 레이블 for 문을 탈출한다.</span></span><br><span class="line">    <span class="keyword">if</span> (i + j === <span class="number">3</span>) <span class="keyword">break</span> outer;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'inner '</span> + j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Done!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// break문 예제</span></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">'Hello World.'</span>;</span><br><span class="line"><span class="keyword">var</span> search = <span class="string">'l'</span>;</span><br><span class="line"><span class="keyword">var</span> index;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열은 유사배열이므로 for 문으로 순회할 수 있다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; string.length; i++) &#123;</span><br><span class="line">  <span class="comment">// 문자열의 개별 문자가 'l'이면</span></span><br><span class="line">  <span class="keyword">if</span> (string[i] === search) &#123;</span><br><span class="line">    index = i;</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 반복문을 탈출한다.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(index); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 참고로 String.prototype.indexOf 메소드를 사용해도 같은 동작을 한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(string.indexOf(search)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><hr><h2 id="continue문-Continue-Statement"><a href="#continue문-Continue-Statement" class="headerlink" title="continue문(Continue Statement)"></a><strong>continue문</strong>(Continue Statement)</h2><p><strong>continue 문</strong>은 <strong>반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 이동</strong>한다.</p><p>break 문처럼 반복문을 탈출하지는 않는다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">'Hello World.'</span>;</span><br><span class="line"><span class="keyword">var</span> search = <span class="string">'l'</span>;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열은 유사배열이므로 for 문으로 순회할 수 있다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; string.length; i++) &#123;</span><br><span class="line">  <span class="comment">// 'l'이 아니면 현 지점에서 실행을 중단하고 반복문의 증감식으로 이동한다.</span></span><br><span class="line">  <span class="keyword">if</span> (string[i] !== search) <span class="keyword">continue</span>;</span><br><span class="line">  count++; <span class="comment">// continue 문이 실행되면 이 문은 실행되지 않는다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 참고로 String.prototype.match 메소드를 사용해도 같은 동작을 한다.</span></span><br><span class="line"><span class="keyword">const</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(search, <span class="string">'g'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(string.match(regexp).length); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><hr><hr><br><p><strong>참고</strong> 👏</p><ul><li><a href="https://poiemaweb.com/js-control-flow">PoiemaWeb - 제어문</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/tags/javascript/"/>
    
    <category term="control flow" scheme="https://jimmyjoo.github.io/tags/control-flow/"/>
    
    <category term="poiemaweb" scheme="https://jimmyjoo.github.io/tags/poiemaweb/"/>
    
  </entry>
  
  <entry>
    <title>연산자(Operator)</title>
    <link href="https://jimmyjoo.github.io/2020/07/08/js/7.%20Operator/"/>
    <id>https://jimmyjoo.github.io/2020/07/08/js/7.%20Operator/</id>
    <published>2020-07-08T12:03:12.000Z</published>
    <updated>2020-09-23T01:17:36.846Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p><strong>연산자</strong>는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산(operation) 등을 수행해 <strong>하나의 값</strong>을 만든다.</p><p><code>const sum = 1 + 2</code></p><p>이때 <code>+</code>가 바로 <strong>연산자</strong>이다.<br><code>1</code>과 <code>2</code>는 <strong>피연산자</strong>라고 부른다.</p><hr><h2 id="연산자의-부수-효과-📍"><a href="#연산자의-부수-효과-📍" class="headerlink" title="연산자의 부수 효과 📍"></a><strong>연산자의 부수 효과</strong> 📍</h2><p>연산자의 <strong>부수효과(Side Effect)</strong>란 피연산자의 값을 변경시키는 것을 의미한다.<br>예를 들어 단항 산술 연산자에서 <code>++</code>(증가 연산자)는 피연산자의 값을 변경시킨다.<br>그러나 <code>1 + 2</code>에서 <code>+</code> 연산자는 새로운 값인 3을 생성하지만 피연산자인 <code>1</code>, <code>2</code>의 값을 변경시키지 않는다.</p><p>부수효과가 있는 연산자는<br>1️⃣ <strong>할당(<code>=</code>) 연산자</strong><br>2️⃣ <strong>증가/감소(<code>++</code>/<code>--</code>) 연산자</strong><br>3️⃣ <strong><code>delete</code> 연산자</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 할당 연산자는 변수 값이 변하는 부수 효과가 있다.</span></span><br><span class="line"><span class="comment">// 이는 변수 x를 사용하는 다른 코드에 영향을 준다.</span></span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 증가/감소(++/--) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다.</span></span><br><span class="line"><span class="comment">// 피연산자 x의 값이 변경된다. 이는 변수 x를 사용하는 다른 코드에 영향을 준다.</span></span><br><span class="line">x++;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete 연산자는 객체의 프로퍼티를 삭제하는 부수 효과가 있다.</span></span><br><span class="line"><span class="comment">// 이는 객체 o를 사용하는 다른 코드에 영향을 준다.</span></span><br><span class="line"><span class="keyword">delete</span> o.a;</span><br><span class="line"><span class="built_in">console</span>.log(o); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="산술-연산자-Arithmetic-Operator-📍"><a href="#산술-연산자-Arithmetic-Operator-📍" class="headerlink" title="산술 연산자(Arithmetic Operator) 📍"></a><strong>산술 연산자</strong>(Arithmetic Operator) 📍</h2><p><strong>피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 생성한다.</strong></p><p>단, 산술 연산이 불가능한 경우, <code>NaN</code>을 리턴한다.</p><p>산술 연산자는 피연산자의 개수에 따라 <strong>이항 산술 연산자</strong>와 <strong>단항 산술 연산자</strong>로 구분할 수 있다.</p><p>👉<strong>이항 산술 연산자</strong><br>말 그대로 항(피연산자) 2개다.<br>종류로는 <code>+</code>(덧셈), <code>-</code>(뺄셈), <code>*</code>(곱셈), <code>/</code>(나눗셈), <code>%</code>(나머지)가 있다.</p><br><p>👉<strong>단항 산술 연산자</strong><br>피연산자는 1개이다.</p><table><thead><tr><th>단항 산술 연산자</th><th>의미</th><th>부수 효과</th></tr></thead><tbody><tr><td><code>++</code></td><td>증가</td><td>O</td></tr><tr><td><code>--</code></td><td>감소</td><td>O</td></tr><tr><td><code>+</code></td><td>효과 없음. 음수를 양수로 반전하지도 않는다.</td><td>X</td></tr><tr><td><code>+</code></td><td>양수를 음수로 음수를 양수로 반전한 값을 리턴한다.</td><td>X</td></tr></tbody></table><p><code>++</code>(증가, 부수효과), <code>--</code>(감소, 부수효과)는 피연산자를 변경시킨다.<br>즉, <strong>부수효과가 있다</strong>.</p><p>또한, <strong>위치에 의미</strong>가 있다.<br>피연산자 <strong>앞에 위치</strong>할 경우 먼저 피연산자의 값을 증가/감소 시킨 후 다른 연산을 진행한다.<br>피연산자 <strong>뒤에 위치</strong>할 경우 **먼저 다른 연산을 진행한 후 피연산자의 값을 증가/감소 시킨다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 선할당 후증가</span></span><br><span class="line">result = x++;</span><br><span class="line"><span class="built_in">console</span>.log(result, x); <span class="comment">// 5 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 선증가 후할당</span></span><br><span class="line">result = ++x; <span class="comment">// 현재 x는 6, 먼저 증가되어서 7, 7을 result에 할당</span></span><br><span class="line"><span class="built_in">console</span>.log(result, x); <span class="comment">// 7 7</span></span><br></pre></td></tr></table></figure><p><strong><code>+</code>,<code>-</code> 연산자</strong>는 숫자타입이 아닌 피연산자를 <strong>숫자로 타입 변환</strong>한다. 이때 피연산자를 변경하는 부수효과(side effect)는 없고 숫자타입으로 변환한 새로운 값을 생성해서 리턴한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 아무런 효과가 없다.</span></span><br><span class="line">+<span class="number">10</span>; <span class="comment">// -&gt; 10</span></span><br><span class="line">+<span class="number">-10</span>; <span class="comment">// -&gt; -10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열을 숫자로 타입 변환한다.</span></span><br><span class="line">+<span class="string">'10'</span>; <span class="comment">// -&gt; 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 불리언 값을 숫자로 타입 변환한다.</span></span><br><span class="line">+<span class="literal">true</span>; <span class="comment">// -&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 불리언 값을 숫자로 타입 변환한다.</span></span><br><span class="line">+<span class="literal">false</span>; <span class="comment">// -&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 리턴한다.</span></span><br><span class="line">+<span class="string">'Hello'</span>; <span class="comment">// -&gt; NaN</span></span><br></pre></td></tr></table></figure><br><p>👉<strong>문자열 연결 연산자</strong></p><p><code>+</code>연산자는 피연산자 중 <strong>하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열 연결 연산자</span></span><br><span class="line"><span class="string">'1'</span> + <span class="number">2</span>; <span class="comment">// '12'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 타입변환</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">true</span>; <span class="comment">// 2(1 + 1)</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">false</span>; <span class="comment">// 1(false = 0)</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">null</span>; <span class="comment">// 1(null = 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined는 숫자로 타입 변환되지 않는다</span></span><br><span class="line">+<span class="literal">undefined</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">undefined</span>; <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure><hr><h2 id="할당-연산자-Assignment-Operator-📍"><a href="#할당-연산자-Assignment-Operator-📍" class="headerlink" title="할당 연산자(Assignment Operator) 📍"></a><strong>할당 연산자</strong>(Assignment Operator) 📍</h2><p><strong>우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">x += <span class="number">5</span>; <span class="comment">// x = x + 5;</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line">x -= <span class="number">5</span>; <span class="comment">// x = x - 5;</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">x *= <span class="number">5</span>; <span class="comment">// x = x * 5;</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line">x /= <span class="number">5</span>; <span class="comment">// x = x / 5;</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">x %= <span class="number">5</span>; <span class="comment">// x = x % 5;</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'My name is '</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열 연결 연산자</span></span><br><span class="line">str += <span class="string">'Lee'</span>; <span class="comment">// str = str + 'Lee';</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 'My name is Lee'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 할당문은 표현식인 문이다.</span></span><br><span class="line"><span class="built_in">console</span>.log((x = <span class="number">10</span>)); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b, c;</span><br><span class="line"><span class="comment">// 연쇄 할당. 오른쪽에서 왼쪽으로 진행.</span></span><br><span class="line"><span class="comment">// ① c = 0 : 0으로 평가된다</span></span><br><span class="line"><span class="comment">// ② b = 0 : 0으로 평가된다</span></span><br><span class="line"><span class="comment">// ③ a = 0 : 0으로 평가된다</span></span><br><span class="line">a = b = c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// 0 0 0</span></span><br></pre></td></tr></table></figure><hr><h2 id="비교-연산자-Comparison-Operator-📍"><a href="#비교-연산자-Comparison-Operator-📍" class="headerlink" title="비교 연산자(Comparison Operator) 📍"></a><strong>비교 연산자</strong>(Comparison Operator) 📍</h2><p><strong>좌항과 우항의 피연산자를 비교한 다음 그 결과를 <code>boolean</code> 값을 리턴한다.</strong></p><p>👉 <strong>동등(loose) vs 일치(strict) 비교 연산자</strong></p><p><strong>동등 비교 <code>==</code></strong><br><strong>암묵적 타입 변환을 통해 타입을 일치시킨 후, 같은 값인지 비교</strong>한다.<br>따라서 동등한 비교(느슨한)편리한 경우도 있지만 결과를 예측하기 어렵기 때문에 부작용을 읽으킬 수 있어 사용하지 않는 편이 좋다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 동등하다.</span></span><br><span class="line"><span class="number">5</span> == <span class="string">'5'</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 동등 비교. 결과를 예측하기 어렵다.</span></span><br><span class="line"><span class="string">'0'</span> == <span class="string">''</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="number">0</span> == <span class="string">''</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">'0'</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">'false'</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">'0'</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">null</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">undefined</span>; <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure><p><strong>일치 비교 <code>===</code></strong><br><strong>타입도 같고 값도 같은 경우에 한하여 true를 리턴</strong>한다.<br>일치 비교 연산자는 예측하기 쉽기 때문에 대부분의 경우 동등 비교보다는 일치 비교를 사용하자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> == <span class="string">'5'</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="number">5</span> === <span class="number">5</span>; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure><p>❗️일치 비교 연산자에서 주의할 것은 <code>NaN</code>과 <code>0</code>이다.</p><p>NaN은 자신과 일치하지 않는 유일한 값이다.<br><code>NaN === NaN</code></p><p>따라서 숫자가 <code>NaN</code>인지 조사하려면 빌트인 함수 <code>isNaN</code>을 사용하자!</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 빌트인 함수 isNaN은 주어진 값이 NaN인지 체크하고 그 결과를 리턴한다.</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">10</span>); <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">1</span> + <span class="literal">undefined</span>); <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure><p><code>0</code>의 경우 양의 0과 음의 0을 비교하였을 때 일치 비교와 동등 비교 둘 다 true를 리턴한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 &#x3D;&#x3D;&#x3D; -0; &#x2F;&#x2F; -&gt; true</span><br><span class="line">0 &#x3D;&#x3D; -0 &#x2F;&#x2F; -&gt; true</span><br></pre></td></tr></table></figure><br><p>🧐<strong><code>Object.is</code>메소드</strong><br>ES6에서 새롭게 도입된 <code>Object.is</code> 메소드는 예측 가능한 정확한 비교 결과를 리턴한다. 마치 일치 비교 연산자(<code>===</code>)와 약점을 보안한 메소드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6 Object.is method</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="number">-0</span>, +<span class="number">0</span>); <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>); <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure><hr><h2 id="비교-연산자-Comparison-Operator-📍-1"><a href="#비교-연산자-Comparison-Operator-📍-1" class="headerlink" title="비교 연산자(Comparison Operator) 📍"></a><strong>비교 연산자</strong>(Comparison Operator) 📍</h2><p><strong>피연산자의 크기를 비교하여 불리언 값을 리턴한다.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 대소 관계 비교</span></span><br><span class="line"><span class="number">5</span> &gt; <span class="number">0</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="number">5</span> &gt; <span class="number">5</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="number">5</span> &gt;= <span class="number">5</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="number">5</span> &lt;= <span class="number">5</span>; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure><hr><h2 id="삼항-조건-연산자-Ternary-Operator-📍"><a href="#삼항-조건-연산자-Ternary-Operator-📍" class="headerlink" title="삼항 조건 연산자(Ternary Operator) 📍"></a><strong>삼항 조건 연산자</strong>(Ternary Operator) 📍</h2><p><strong>조건식의 평가 결과에 따라 리턴할 값을 결정한다.</strong></p><p><code>조건식 ? 조건식이 true일때 리턴값 : 조건식이 false일때 리턴값</code></p><p>자바스크립트의 유일한 삼항 연산자이며 부수 효과는 없다.</p><p>삼항 연산자 표현식은 <strong>표현식인 문</strong>이다.<br>따라서 <strong>값처럼 사용할 수 있다.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = x % <span class="number">2</span> ? <span class="string">'홀수'</span> : <span class="string">'짝수'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 짝수</span></span><br></pre></td></tr></table></figure><hr><h2 id="논리-연산자-Logical-Operator-📍"><a href="#논리-연산자-Logical-Operator-📍" class="headerlink" title="논리 연산자(Logical Operator) 📍"></a><strong>논리 연산자</strong>(Logical Operator) 📍</h2><p><strong>우항과 좌항의 피연산자(부정 논리 연산자의 경우, 우항의 피연산자)를 논리 연산한다.</strong></p><p>부수 효과<br>논리 연산자는 <strong>||(OR, 논리합)</strong>, <strong>&amp;&amp;(AND, 논리곱)</strong>, <strong>!(NOT, 부정)</strong> 총 3가지가 있다.</p><p>논리 부정(!) 연산자는 <strong>언제나 <code>boolean</code> 값을 리턴</strong>한다.<br>만약 피연산자가 <code>boolean</code> 값이 아니라면 <code>boolean</code> 타입으로 암묵적 타입으로 변환된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!<span class="number">0</span>); <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="string">'Hello'</span>); <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure><p>논리합(||) 또는 논리곱(&amp;&amp;) 연산자 표현식은 <strong>언제나 2개의 피연산자 중 어느 한쪽으로 평가</strong>된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 단축 평가</span></span><br><span class="line"><span class="string">'Cat'</span> &amp;&amp; <span class="string">'Dog'</span>; <span class="comment">// -&gt; 'Dog'</span></span><br></pre></td></tr></table></figure><p>더 자세한 내용은 👉<a href="https://jimmyjoo.github.io/2020/07/11/js/9.%20TypeConversion/#more">타입 변환과 단축 평가</a></p><p>🧐 <strong>드 모르간의 법칙</strong><br>중학교 수업시간에 한번쯤은 들어봤을 법칙이다.<br>논리합(<code>||</code>)은 논리곱(<code>&amp;&amp;</code>)과 부정기호(<code>!</code>)로,<br>논리곱(<code>&amp;&amp;</code>)은 논리합(<code>||</code>)과 부정기호(<code>!</code>)로 표현할 수 있음을 가리키는 법칙이다.</p><p>논리 연산자로 구성된 복잡한 표현식의 가독성을 높이기 위해 드 모르간의 법칙을 활용할 수도 있다.<br><code>!(x||y) === (!x &amp;&amp; !y)</code></p><hr><h2 id="쉼표-연산자-📍"><a href="#쉼표-연산자-📍" class="headerlink" title="쉼표 연산자 📍"></a><strong>쉼표 연산자</strong> 📍</h2><p><strong>왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 리턴한다.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y, z;</span><br><span class="line"></span><br><span class="line">(x = <span class="number">1</span>), (y = <span class="number">2</span>), (z = <span class="number">3</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><hr><h2 id="그룹-연산자-📍"><a href="#그룹-연산자-📍" class="headerlink" title="그룹 연산자 📍"></a><strong>그룹 연산자</strong> 📍</h2><p><strong>그룹 연산자를 사용하면 연산자의 우선 순위를 조절할 수 있다.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 그룹 연산자를 사용하여 우선 순위 조절</span></span><br><span class="line"><span class="number">10</span> * (<span class="number">2</span> + <span class="number">3</span>); <span class="comment">// -&gt; 50</span></span><br></pre></td></tr></table></figure><hr><h2 id="typeof-연산자-📍"><a href="#typeof-연산자-📍" class="headerlink" title="typeof 연산자 📍"></a><strong>typeof 연산자</strong> 📍</h2><p><strong>피연산자의 데이터 타입을 문자열로 리턴한다.</strong></p><p>7가지 문자열 “string”, “number”, “boolean”, “undefined”, “symbol”, “object”, “function” 중 하나를 리턴한다.</p><p>❗️<code>typeof null</code>은 “object”를 반환한다. (버그)<br>따라서, null 타입을 확인할 때는 typeof 연산자를 사용하지 말고 일치 연산자(===)를 사용하자.</p><p>또한, 선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 “undefined”를 리턴</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">''</span>; <span class="comment">// -&gt; "string"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">// -&gt; "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// -&gt; "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// -&gt; "boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// -&gt; "undefined"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(); <span class="comment">// -&gt; "symbol"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// -&gt; "object"</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// -&gt; "object"</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// -&gt; "object"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// -&gt; "object"</span></span><br><span class="line"><span class="keyword">typeof</span> /test/gi; <span class="comment">// -&gt; "object"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// -&gt; "function"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 식별자 undeclared는 선언한 적이 없다.</span></span><br><span class="line"><span class="keyword">typeof</span> undeclared; <span class="comment">// -&gt; undefined</span></span><br></pre></td></tr></table></figure><hr><h2 id="지수-연산자-📍"><a href="#지수-연산자-📍" class="headerlink" title="지수 연산자 📍"></a><strong>지수 연산자</strong> 📍</h2><p>ES7부터 도입된 지수 연산자는 <strong>좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 타입의 값을 리턴한다.</strong></p><p>(그 전에는 <code>Math.pow</code> 메소드를 사용하였다.)</p><p>음수를 거듭제곱의 밑으로 계산하려면 아래와 같이 괄호로 묶어야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span>; <span class="comment">// -&gt; 4</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">2.5</span>; <span class="comment">// -&gt; 5.65685424949238</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">0</span>; <span class="comment">// -&gt; 1</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">-2</span>; <span class="comment">// -&gt; 0.25</span></span><br><span class="line">(<span class="number">-5</span>) ** <span class="number">2</span>; <span class="comment">// -&gt; 25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">5</span>;</span><br><span class="line">num **= <span class="number">2</span>; <span class="comment">// -&gt; 25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES7 이전</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// -&gt; 4</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">2.5</span>); <span class="comment">// -&gt; 5.65685424949238</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">0</span>); <span class="comment">// -&gt; 1</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">-2</span>); <span class="comment">// -&gt; 0.25</span></span><br></pre></td></tr></table></figure><hr><hr><br><p><strong>참고</strong> 👏</p><ul><li><a href="https://poiemaweb.com/js-operator">PoiemaWeb - 연산자</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/tags/javascript/"/>
    
    <category term="operator" scheme="https://jimmyjoo.github.io/tags/operator/"/>
    
    <category term="poiemaweb" scheme="https://jimmyjoo.github.io/tags/poiemaweb/"/>
    
  </entry>
  
  <entry>
    <title>데이터 타입(Data Type)</title>
    <link href="https://jimmyjoo.github.io/2020/07/05/js/6.%20DataType/"/>
    <id>https://jimmyjoo.github.io/2020/07/05/js/6.%20DataType/</id>
    <published>2020-07-05T11:45:43.000Z</published>
    <updated>2020-09-16T07:50:34.045Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h2 id="데이터-타입이란-📍"><a href="#데이터-타입이란-📍" class="headerlink" title="데이터 타입이란? 📍"></a><strong>데이터 타입이란?</strong> 📍</h2><p><code>데이터 타입</code>이란 값의 종류를 말한다. 줄여서 <strong>타입</strong>이라고 말하기도 한다.<br>자바스크립트의 <strong>모든 값</strong>은 데이터 타입을 갖는다.</p><p>그리고 <code>원시타입</code>과 <code>객체타입</code>으로 구분할 수 있다.</p><p>원시 타입과 객체 타입의 비교에 대해 좀 더 자세한 내용은<br>👇<br><a href="https://jimmyjoo.github.io/2020/07/15/js/11.%20TypeComparison/">원시값과 객체의 비교</a></p><hr><h2 id="데이터-타입의-필요성-📍"><a href="#데이터-타입의-필요성-📍" class="headerlink" title="데이터 타입의 필요성 📍"></a><strong>데이터 타입의 필요성</strong> 📍</h2><p>그렇다면 데이터 타입이 <strong>왜</strong> 필요한 거야?? 🤔</p><p>1️⃣ <strong>데이터 타입에 의한 메모리 공간의 확보와 참조</strong></p><p>값은 메모리에 <strong>저장</strong>하고 <strong>참조</strong>할 수 있어야 한다.</p><p>먼저, <strong>저장</strong>할 때를 생각해보자.</p><p>메모리에 값을 저장할 때 확보해야 할 메모리 공간의 크기를 알아야한다.<br>(무작정 큰 거 주면 되겠지? 적당히~ 넉넉하게~ 🥴?? 너무 비효율적이다! 🤬)<br>따라서, 자바스크립트 엔진은 값의 종류(데이터 타입)에 따라서 정해진 크기의 메모리 공간을 확보한다. 즉, <strong>변수에 할당되는 데이터 타입에 따라 메모리의 공간의 크기가 결정</strong>된다.</p><p>값을 <strong>참조</strong>할때도 마찬가지로 메모리 공간의 크기를 알아야한다.<br>몇 바이트를 읽어 들일건지 정해야 하기 때문이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">var</span>);</span><br></pre></td></tr></table></figure><p>위 코드를 보면 <code>console.log(var)</code>를 통해 변수 <code>var</code>를 참조한다. 그렇다면 컴퓨터는 몇 칸의 메모리 셀을 읽어들여야 할까?<br>그걸 알려주는 것이 값의 타입이다.<br>현재 변수 <code>var</code>는 <code>number</code>인 100이 할당되어 있다. 자바스크립트에서 <code>number</code> 타입은 8byte 단위로 저장되어 있으므로 8byte 단위로 값을 읽어 들인다.</p><br><p>2️⃣ <strong>데이터 타입에 의한 값의 해석</strong><br>컴퓨터는 모든 값을 2진수로 처리한다.<br>예를 들어, <code>var b = 65</code>에서 65도 사실은 메모리공간에 0과 1로만 저장되어있다.<br>하지만, 메모리에 저장되어있는 01000001은 숫자로 해석하면 65이지만 문자열로 해석하면 ‘A’이다.<br>이 때, 변수 <code>b</code>에 할당된 값이 숫자타입이였기 때문에 2진수를 숫자로 해석한다.</p><br>정리해보자면,<p>👉 <strong>값을 저장할 때 확보해야 하는 메모리 크기와 값을 참조할 때 한번에 읽어 들여야 할 메모리 크기를 결정한다.</strong><br>👉 <strong>메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정한다.</strong></p><hr><h2 id="원시타입-Primitive-Data-Type-의-종류-📍"><a href="#원시타입-Primitive-Data-Type-의-종류-📍" class="headerlink" title="원시타입(Primitive Data Type)의 종류 📍"></a><strong>원시타입</strong>(Primitive Data Type)의 종류 📍</h2><p>자바스크립트의 원시타입에는 6개의 종류가 있다.</p><p>▪️<code>number</code><br>▪️<code>string</code><br>▪️<code>boolean</code><br>▪️<code>null</code><br>▪️<code>undefined</code><br>▪️<code>symbol</code> (ES6에서 추가되었다.)<br><br></p><h3 id="숫자-number"><a href="#숫자-number" class="headerlink" title="숫자(number)"></a><strong>숫자</strong>(<code>number</code>)</h3><p>자바스크립트에서 <code>number</code>는 <strong>모두 실수</strong>로 처리되며 8 byte이다.</p><p>모두 실수로 처리되기 때문에 소숫점이 없는 정수로 보여도 사실은 실수다.<br>정수를 정수로 나눴을 때 결과값은 실수!</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">7</span> / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num) = <span class="number">3.5</span>; <span class="comment">//출력값: 3.5</span></span><br></pre></td></tr></table></figure><br><p>또한 3가지 특별한 값들도 표현할 수 있다.<br>∙ <code>Infinity</code>: 양의 무한대<br>∙ <code>-Infinity</code>: 음의 무한대<br>∙ <code>NaN</code>: 산술 연산 불가(Not-a-Number)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">10</span> / <span class="number">0</span>); <span class="comment">// Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">10</span> / <span class="number">-10</span>); <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> * <span class="string">'String'</span>); <span class="comment">// NaN(Not-a-Number)</span></span><br></pre></td></tr></table></figure><br><h3 id="문자열-string"><a href="#문자열-string" class="headerlink" title="문자열(string)"></a><strong>문자열</strong>(<code>string</code>)</h3><p>문자열은 0개 이상의 16bit 유니코드 문자(UTF-16)들의 집합이며 텍스트 데이터를 나타내는데 사용한다.</p><p>텍스트를 작은 따옴표(<code>&#39;&#39;</code>), 큰 따옴표(<code>&quot;&quot;</code>), 또는 백틱(<code>``</code>)으로 감싸면 된다.<br>백틱을 사용하면 ES6에서 추가된 템플릿 리터럴이라는 새로운 문자열 표기법이다.</p><p>문자열은 인덱스를 통해 접근 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span>;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'H'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">//출력값: 'hello'. 변경되지 않은 이유는 문자열은 immutable</span></span><br></pre></td></tr></table></figure><p>C언어와는 다르게 <strong>문자열은 원시타입이고 따라서 변경 불가능(immutable)</strong>하다.<br>따라서, 새로운 문자열을 재할당하는 것은 가능하다.<br>기존 문자열을 변경하는 것이 아니라 새로운 문자열을 새롭게 할당하는 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 'hello'</span></span><br><span class="line">str += <span class="string">'Jimmy'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 'helloJimmy'</span></span><br></pre></td></tr></table></figure><br><h4 id="템플릿-리터럴"><a href="#템플릿-리터럴" class="headerlink" title="템플릿 리터럴"></a><strong>템플릿 리터럴</strong></h4><p>ES6부터 도입된 새로운 문자열 표기법이다.</p><p><strong>백틱(<code>``</code>)사용</strong>한다.</p><p>멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 여러가지의 편리한 문자열 처리 기능 제공한다.</p><p>템플릿 리터럴은 런타임에 일반 문자열로 변환되어 처리된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 멀티라인 문자열</span></span><br><span class="line"><span class="keyword">var</span> template = <span class="string">`&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;&lt;a href="#"&gt;Home&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 표현식 삽입</span></span><br><span class="line"><span class="keyword">var</span> first = <span class="string">'Jimmy'</span>;</span><br><span class="line"><span class="keyword">var</span> last = <span class="string">'Joo'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>.`</span>);</span><br></pre></td></tr></table></figure><p>(템플릿 리터럴의 좀 더 자세한 내용은 나중에 정리를 해야겠다.<br>특히 태그드 템플릿 기능에 대해 좀 더 공부가 필요하다. 📝)</p><br><h3 id="불리언-boolean"><a href="#불리언-boolean" class="headerlink" title="불리언(boolean)"></a><strong>불리언</strong>(<code>boolean</code>)</h3><p>논리적 참과 거짓을 나타낸다.</p><p>값은 참을 나타내는 <code>true</code>, 거짓을 나타내는 <code>false</code> 뿐이다.<br><br></p><h3 id="undefined-undefined"><a href="#undefined-undefined" class="headerlink" title="undefined(undefined)"></a><strong>undefined</strong>(<code>undefined</code>)</h3><p>변수 선언 이후에 값을 할당하지 않으면 자바스크립트 엔진에 의해 변수의 값이 <code>undefined</code>로 초기화된다.</p><p>이를 통해 개발자가 변수를 참조할 때 <code>undefined</code>가 반환된다면 변수에 할당을 한 적이 없다는 것을 알 수 있다.</p><p>따라서 의도적으로 변수에 <code>undefined</code>를 할당하지 말자.<br>변수에 값이 없다는 것을 명시하고 싶다면 <code>null</code>을 할당하자!</p><br><h3 id="null-null"><a href="#null-null" class="headerlink" title="null(null)"></a><strong>null</strong>(<code>null</code>)</h3><p>의도적으로 변수에 값이 없다는 것을 명시하기 위한 값이다.</p><p>또한, 함수가 호출되었으나 유효한 값을 반환할 수 없는 경우, 명시적으로 <code>null</code> 반환하기도 한다.</p><p>아래 코드를 보면 document.querySelector 메소드는 myElem이라는 클래스를 가진 HTML요소를 검색할 수 없다.<br>이럴 경우 에러가 아니라 <code>null</code>을 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.querySelector(<span class="string">'.myElem'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(element); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>❗️주의할점 <code>typeof</code>로 확인하면 <code>object</code>나온다.<br>이럴때는 일치연산자(===) 사용해서 확인하자!<br><br></p><h3 id="symbol-symbol"><a href="#symbol-symbol" class="headerlink" title="symbol(symbol)"></a><strong>symbol</strong>(<code>symbol</code>)</h3><p>심볼(<code>symbol</code>)은 ES6에서 추가되었다.<br>주로 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키(property key)를 만들기 위해 사용한다.</p><p><code>Symbol</code> 함수를 호출해 생성한다. 이때 생성된 심볼 값은 노출되지 않고 다른 값과 절대 중복되지 않는 값이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key = <span class="built_in">Symbol</span>(<span class="string">'key'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj[key] = <span class="string">'value'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj[key]); <span class="comment">// value</span></span><br></pre></td></tr></table></figure><p><br><br></p><hr><h2 id="객체-타입-Object-Reference-Data-Type-📍"><a href="#객체-타입-Object-Reference-Data-Type-📍" class="headerlink" title="객체 타입(Object/Reference Data Type) 📍"></a><strong>객체 타입</strong>(Object/Reference Data Type) 📍</h2><p>👉<code>객체</code>란 <strong>데이터(property)와 그 데이터에 관련한 동작(method)을 모두 포함할 수 있는 독립적 주체</strong>이다.</p><p>자바스크립트를 이루고 있는 거의 ‘모든 것’이 객체이다.<br>원시 타입을 제외한 나머지 값들(배열, 함수, 정규표현식 등)은 모두 객체다.</p><p>객체의 중요한 특징은 <strong>참조에 의한 전달(pass-by-reference)</strong>이다.</p><p>객체(구체적으로 표현하자면 객체 리터럴)에 대한 내용은<br>👇<br><a href="https://jimmyjoo.github.io/2020/07/15/js/10.%20ObjectLiteral/">객체</a></p><p><br><br></p><hr><h2 id="정적-타입-언어와-동적-타입-언어-📍"><a href="#정적-타입-언어와-동적-타입-언어-📍" class="headerlink" title="정적 타입 언어와 동적 타입 언어 📍"></a><strong>정적 타입 언어와 동적 타입 언어</strong> 📍</h2><p>프로그래밍 언어를 타입 언어로 구분한다면 <strong>정적 타입 언어</strong>와 <strong>동적 타입 언어</strong>로 구분할 수 있다.</p><p>그렇다면 자바스크립트는 어떤 타입 언어일까?<br>바로 <strong>동적 타입 언어</strong>!</p><p>동적 타입 언어에 대해 알아보기 전에 먼저 정적 타입 언어에 대해 알아보자.</p><br><p><strong>정적 타입(Static/Strong type) 언어</strong><br>정적 타입 언어로는 대표적으로 C, C++, Java를 들 수 있다.</p><p>정적 타입 언어는 <strong>변수를 선언할 때 데이터 타입이 결정</strong>된다. 그리고 변수의 타입을 런타임에 변경할 수 없으며 변수에 선언한 타입에 맞는 값만을 할당할 수 있다. (컴파일 시점에 타입 체크를 통해 에러를 발생시키고 프로그램 실행 자체를 막는다.)</p><p>즉, 한 번 타입이 정해지면 런타임에는 변경할 수 없기 때문에 <strong>정적</strong> 타입 언어라 불린다.</p><p>(좀 빡빡한 친구구만..🤨)</p><p>하지만, 타입의 일관성을 강제하여 보다 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄일 수 있다는 장점이 있다.👍</p><br><p>그렇다면 <strong>동적 타입 언어</strong>는 어떨까?</p><p><strong>동적 타입(Dynamic/Weak type) 언어</strong><br>대표적으로 <strong>JavaScript</strong>, Python, Ruby 등을 들 수 있다.</p><p>동적 타입 언어는 <strong>값을 할당하는 시점에 변수의 타입이 결정</strong>된다. 정적 타입 언어와 가장 큰 차이점은 재할당에 의해 변수의 타입이 언제든지 자유롭게 변경 가능하다.</p><p>즉, 런타임에 <strong>동적으로 변수의 타입이 변경 가능</strong>하므로 <strong>동적</strong> 타입 언어라 불린다.</p><p>하지만, 단점으로는 변화하는 변수 값 추적하기 어렵고 값의 신뢰성이 떨어진다.</p><p>(“chill”하고 “free”한 느낌? 🏝 대신 디버깅이 어렵다…🥵)</p><br><p>따라서, 변수를 사용할 때는 몇 가지를 주의하자!</p><p>🚨<strong>주의사항</strong><br>▪️변수를 남발하지 말자. 필요한 경우에 한해 제한적으로 사용하자.<br>▪️유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제하자.<br>▪️전역 변수의 사용은 지양하자.<br>▪️변수보다는 상수를 사용해 값의 변경을 억제하자. (<code>const</code>)<br>▪️명확하고 구체적인 변수명 네이밍을 통해 변수의 목적과 의미를 정확하게 전달하자</p><hr><hr><br><p><strong>참고</strong> 👏</p><ul><li><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures">MDN - 자바스크립트의 자료형</a></p></li><li><p><a href="https://poiemaweb.com/js-data-type-variable">PoiemaWeb - 데이터 타입과 변수</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/tags/javascript/"/>
    
    <category term="data type" scheme="https://jimmyjoo.github.io/tags/data-type/"/>
    
    <category term="poiemaweb" scheme="https://jimmyjoo.github.io/tags/poiemaweb/"/>
    
  </entry>
  
  <entry>
    <title>표현식과 문(Expression &amp; Statement)</title>
    <link href="https://jimmyjoo.github.io/2020/07/04/js/5.%20Expression&amp;Statement/"/>
    <id>https://jimmyjoo.github.io/2020/07/04/js/5.%20Expression&amp;Statement/</id>
    <published>2020-07-04T09:12:43.000Z</published>
    <updated>2020-09-16T07:49:27.214Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h2 id="값-Value-📍"><a href="#값-Value-📍" class="headerlink" title="값(Value)📍"></a><strong>값(Value)📍</strong></h2><p><strong>👉 식(표현식, Expression)이 평가(Evaluate)되어 생성된 결과</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1+2라는 식이 평가되어 3이라는 숫자값을 생성</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span>; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sum이라는 변수에 1 + 2 라는 식이 평가되어 생성된 3이라는 숫자값을 할당</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>값은 다양한 방법으로 생성할 수 있다.<br>그 중에서 가장 기본적인 방법은 <code>리터럴</code>을 생성하는 것이다.</p><hr><h2 id="리터럴-Literal-📍"><a href="#리터럴-Literal-📍" class="headerlink" title="리터럴(Literal)📍"></a><strong>리터럴(Literal)📍</strong></h2><p><strong>👉 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기 방식</strong></p><p>JS엔진이 런타임에 리터럴을 평가하여 값을 생성한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>         <span class="comment">// 정수 리터럴</span></span><br><span class="line"><span class="string">'Hello'</span>   <span class="comment">// 문자열 리터럴</span></span><br><span class="line"><span class="literal">true</span>      <span class="comment">// 불리언 리터럴</span></span><br><span class="line"><span class="literal">null</span>      <span class="comment">// null 리터럴</span></span><br><span class="line"><span class="literal">undefined</span> <span class="comment">// undefined 리터럴</span></span><br><span class="line">&#123; <span class="attr">name</span> : <span class="string">'Jimmy'</span>&#125; <span class="comment">// 객체 리터럴</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>]     <span class="comment">// 배열 리터럴</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 함수 리터럴</span></span><br><span class="line">/^[<span class="number">0</span><span class="number">-9</span>]+$/ <span class="comment">// 정규 표현식 리터럴</span></span><br></pre></td></tr></table></figure><hr><h2 id="표현식-Expression-📍"><a href="#표현식-Expression-📍" class="headerlink" title="표현식(Expression)📍"></a><strong>표현식(Expression)📍</strong></h2><p><strong>👉 값으로 평가될 수 있는 문(Statement)</strong></p><p>표현식이 평가되면 값을 생성하거나 값을 참조한다.<br>리터럴은 값으로 평가되기 때문에 <strong>리터럴도 표현식</strong>이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 리터럴 표현식(JS엔진에 의해 런타임에 평가되어 값 생성 =&gt; 표현식)</span></span><br><span class="line"><span class="number">100</span>;</span><br><span class="line">(<span class="string">'Jimmy'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 식별자 표현식(식별자 참조)</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">50</span>;</span><br><span class="line">sum; <span class="comment">// -&gt; 변수 sum에 100이라는 값이 할당되어 있다면 참조를 통해 값(100)이 평가됨 =&gt; 표현식</span></span><br><span class="line">person.name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 연산자 표현식</span></span><br><span class="line"><span class="number">10</span> + <span class="number">20</span>;</span><br><span class="line">sum = <span class="number">10</span>;</span><br><span class="line">sum === <span class="number">10</span>; <span class="comment">// true라는 값을 생성</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수/메소드 호출 표현식</span></span><br><span class="line">getSum();</span><br><span class="line">person.getAge();</span><br></pre></td></tr></table></figure><p>표현식과 표현식이 평가된 값은 동치(equivalent)이다.</p><p>즉, 표현식을 값처럼 사용 가능 → 값이 위치할 수 있는 자리에 표현식도 위치할 수 있다. (e.g. 변수에 지정 가능)</p><hr><h2 id="문-Statement-📍"><a href="#문-Statement-📍" class="headerlink" title="문(Statement)📍"></a><strong>문(Statement)📍</strong></h2><p><strong>👉 프로그램을 구성하는 기본 단위이자 최소 실행 단위</strong></p><p>쉽게 말해 컴퓨터에 내리는 명령이다.<br>그리고 문들은 <code>토큰(token)</code> 들로 구성되어있다.</p><p><code>토큰</code>이란 <strong>문법적인 의미를 가지며, 문법적으로 더이상 나눌 수 없는 코드의 기본 요소</strong>를 말한다.<br>예를 들어, 키워드, 식별자, 연산자, 리터럴, 세미콜론, 마침표 등이 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> product = <span class="number">4</span> * <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>문에는 여러 종류가 있다.<br>대표적으로 <strong>선언문</strong>, <strong>할당문</strong>, <strong>조건문</strong>, <strong>반복문</strong>으로 구분할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 선언문</span></span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 할당문</span></span><br><span class="line">name = <span class="string">'Jimmy'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 조건문</span></span><br><span class="line"><span class="keyword">if</span> (score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Your grade is A'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반복문</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><hr><h2 id="세미콜론-Semicolon-📍"><a href="#세미콜론-Semicolon-📍" class="headerlink" title="세미콜론(Semicolon)📍"></a><strong>세미콜론(Semicolon)📍</strong></h2><p><code>세미콜론(;)</code>은 문(statement)의 종료를 나타낸다.</p><p>따라서 문은 세미콜론으로 끝나야 한다.<br>단, 0개 이상의 문을 중괄호(<code>{ }</code>)로 묶은 코드블록 뒤에는 붙이지 않는다. (e.g. if문, for문, 함수)</p><p>하지만, 세미콜론을 붙이는 것은 <strong>옵션!</strong>이다.</p><p>그 것은 바로 <strong>세미콜론 자동 삽입 기능</strong>(ASI, Automatic Semicolon Insertion) 때문이다.<br>이 기능은 JS엔진이 코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여준다.</p><p>❗️문제점: 개발자의 의도와 다를수 있다.</p><br><hr><h2 id="표현식인-문과-표현식이-아닌-문📍"><a href="#표현식인-문과-표현식이-아닌-문📍" class="headerlink" title="표현식인 문과 표현식이 아닌 문📍"></a><strong>표현식인 문과 표현식이 아닌 문📍</strong></h2><p>표현식과 문의 개념을 헷갈리지 말자.🤯</p><p>문에는 표현식인 문과 표현식이 아닌 문이 있다.<br><strong>표현식인 문</strong>은 값으로 평가될 수 있는 문이다.<br><strong>표현식이 아닌 문</strong>은 값으로 평가될 수 없다.</p><p>간단하게 구분하는 방법이 있다.<br>바로 변수에 할당하기!😎</p><p>표현식인 문은 값으로 평가되므로 변수에 할당이 가능하다.<br>반대의 경우 에러🚫가 발생한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 선언문 =&gt; 값 평가 X, 즉 표현식이 아닌 문</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">var</span> x; <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 할당문 =&gt; 값으로 평가됨 =&gt; 표현식인 문</span></span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> y = x = <span class="number">100</span>; <span class="comment">// x에 100 할당되고 y에 x의 값(100)이 할당됨</span></span><br></pre></td></tr></table></figure><p>크롬 개발자 도구에서 표현식이 아닌 문은 언제나 <code>undefined</code>를 출력한다.</p><br><hr><hr><br><p><strong>참고</strong>👏</p><ul><li><a href="https://poiemaweb.com/js-syntax-basics">PoiemaWeb - 자바스크립트의 기본 문법</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/tags/javascript/"/>
    
    <category term="expression" scheme="https://jimmyjoo.github.io/tags/expression/"/>
    
    <category term="statement" scheme="https://jimmyjoo.github.io/tags/statement/"/>
    
    <category term="poiemaweb" scheme="https://jimmyjoo.github.io/tags/poiemaweb/"/>
    
  </entry>
  
  <entry>
    <title>변수(Variable)</title>
    <link href="https://jimmyjoo.github.io/2020/07/03/js/4.%20Variable/"/>
    <id>https://jimmyjoo.github.io/2020/07/03/js/4.%20Variable/</id>
    <published>2020-07-03T09:04:11.000Z</published>
    <updated>2020-09-16T07:48:09.721Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h2 id="변수-Variable-의-정의와-필요성📍"><a href="#변수-Variable-의-정의와-필요성📍" class="headerlink" title="변수(Variable)의 정의와 필요성📍"></a><strong>변수(Variable)의 정의와 필요성📍</strong></h2><p><code>변수</code>란 간단하게 말해서 상자다. 하나의 물건(값, 데이터)을 담고 저장할 수 있는 상자!</p><p>그렇다면 변수가 왜 필요한걸까?</p><p>기억하고 싶은 값을 메모리에 저장하고 <strong>안전하게(?) 재사용</strong>하기 위해서이다.</p><p><strong>안전하게??🤔</strong><br>모든 값들은 메모리(메모리 셀의 집합)에 저장되어 있고 각각의 메모리 셀은 주소를 가지고 있다. 하지만 메모리 주소를 통해 값에 직접 접근하는 것은 치명적인 오류를 생산할 가능성이 존재하기 때문에 자바스크립트는 직접적인 메모리 제어를 허용하지 않는다.</p><p><strong>재사용!🙂</strong><br>직접적인 메모리 제어를 허용한다 하더라도 재사용적인 측면에서 문제가 생긴다. 코드가 실행될 때 메모리의 상황에 따라 메모리 주소가 임의로 결정되기 때문에 값이 저장될 메모리 주소가 변경되어 재사용할 수 없다.</p><p>👉즉, <code>변수</code>란 <strong>하나의 값을 저장하기 위해 확보한 메모리 공간 자체</strong> 또는 <strong>그 메모리 공간을 식별하기 위해 붙인 이름</strong>이다.</p><hr><h2 id="식별자-Identifier-📍"><a href="#식별자-Identifier-📍" class="headerlink" title="식별자(Identifier)📍"></a><strong>식별자</strong>(Identifier)📍</h2><p>변수 이름을 <code>식별자</code>라고도 부른다.</p><p><code>식별자</code>란 <strong>어떤 값을 구별하여 식별해낼 수 있는 고유한 이름</strong>이다.</p><p>따라서, 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별하여 식별해낼수 있어야 한다.</p><p>식별자는 값이 아니라 메모리 주소를 기억하고 있다. 값을 담고 있는 메모리 주소. <code>식별자</code>는 <strong>메모리 주소에 붙인 이름</strong>이다.</p><p>(🤨변수도 메모리 주소에 붙인 이름인데?? 뭐가 다른거야??)<br>식별자가 변수를 포함하는 용어이다. 변수, 함수, 클래스 등의 모든 이름은 식별자다.</p><p>그리고 식별자는 네이밍 규칙을 준수해야하며, 선언(declaration)을 통해 자바스크립트 엔진에 식별자의 존재를 알린다.</p><hr><h2 id="변수선언-Declaration-📍"><a href="#변수선언-Declaration-📍" class="headerlink" title="변수선언(Declaration)📍"></a><strong>변수선언</strong>(Declaration)📍</h2><p>변수를 사용하려면 먼저 변수를 생성해야한다.</p><p><strong>변수 선언</strong>이란 쉽게 말해 변수를 생성하는 것이다.<br>좀 더 구체적으로 말하자면 값을 저장하기 위한 메모리 공간 확보(allocate) 후 변수 이름과 메모리 주소 연결(mapping)한다. 확보 해제 전까지 메모리 공간 보호된다.</p><p>변수를 선언할 때는 <code>var</code>, <code>let</code>, <code>const</code> 키워드를 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 변수 선언문</span></span><br><span class="line"><span class="keyword">var</span> name;</span><br></pre></td></tr></table></figure><p>변수 선언문은 2가지 단계를 거쳐 수행된다.</p><p>1️⃣<strong>선언 단계(Declaration phase)</strong><br>변수 이름을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다.</p><p>2️⃣<strong>초기화 단계(Initialization phase)</strong><br>값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 <code>undefined</code>를 할당한다.</p><p>(도대체 어디에 등록한다는거야?? 🤨)<br>바로, <strong>실행 컨텍스트(execution context)!</strong></p><p>자바스크립트 엔진이 소스 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역.<br>변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록된다.</p><hr><h2 id="변수-호이스팅-Variable-Hoisting-📍"><a href="#변수-호이스팅-Variable-Hoisting-📍" class="headerlink" title="변수 호이스팅(Variable Hoisting)📍"></a><strong>변수 호이스팅</strong>(Variable Hoisting)📍</h2><p><strong>변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Jimmy'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">//'Jimmy'</span></span><br></pre></td></tr></table></figure><p>호이스팅이 없었다면?<br>변수 <code>name</code>을 선언하기 전에 <code>console.log(name)</code>을 통해 <code>name</code>을 참조하기 때문에 Reference Error가 발생해야 한다.</p><p>하지만, Reference Error 발생되지 않고 <code>undefined</code>가 출력된다.</p><p>Why?? 바로 <code>변수 호이스팅!</code><br><strong>모든 선언문은 런타임(코드가 한 줄씩 실행되는 시점) 이전 단계에서 실행된다.</strong><br>실행되면서 모든 값을 <code>undefined</code>로 초기화 된다.</p><p>사실 변수 선언뿐만이 아니라 함수, 클래스 선언문도 호이스팅된다.</p><hr><h2 id="변수에-값-할당-Assignment-📍"><a href="#변수에-값-할당-Assignment-📍" class="headerlink" title="변수에 값 할당(Assignment)📍"></a><strong>변수에 값 할당</strong>(Assignment)📍</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> score; <span class="comment">//변수 선언</span></span><br><span class="line"></span><br><span class="line">score = <span class="number">10</span>; <span class="comment">//값 할당</span></span><br></pre></td></tr></table></figure><p>초기화 당시에 자바스크립트 엔진에 의해 <code>undefined</code>로 암묵적으로 할당된다.</p><p>그 이후에 새로운 값을 위해 메모리 공간을 확보하고 새로운 값을 저장하는 메모리 주소에 변수를 새롭게 mapping한다.</p><p>따라서, 엄밀히 말하자면 값을 할당할 때도 재할당된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testScore = <span class="number">100</span>; <span class="comment">// testScore가 선언되어있지 않음</span></span><br></pre></td></tr></table></figure><p>선언되어 있지 않은 변수에 값을 할당하면 자바스크립트 엔진에 의해 전역변수(<code>window</code>객체)의 property로 지정된다.</p><hr><h2 id="변수에-값-재할당-Reassignment-📍"><a href="#변수에-값-재할당-Reassignment-📍" class="headerlink" title="변수에 값 재할당(Reassignment)📍"></a><strong>변수에 값 재할당</strong>(Reassignment)📍</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="number">10</span>; <span class="comment">//이미 score로 선언되었다고 가정</span></span><br><span class="line">score = <span class="number">100</span>; <span class="comment">//100으로 재할당</span></span><br></pre></td></tr></table></figure><p>원시값을 재할당 할 때 새로운 메모리 공간에 값을 재할당하고 변수를 그 주소로 새롭게 mapping해준다.</p><p><strong>원시값은 변경불가능(immutable)!</strong></p><p>ES6에서 새롭게 도입된 <code>const</code> 키워드와 헷갈리지 말자! <code>const</code> 키워드는 <strong>재할당 불가능</strong>을 의미하고 원시값은 변경이 불가능하다는 뜻입니다.</p><hr><h2 id="식별자-네이밍-규칙📍"><a href="#식별자-네이밍-규칙📍" class="headerlink" title="식별자 네이밍 규칙📍"></a><strong>식별자 네이밍 규칙</strong>📍</h2><p>▪️식별자는 특수문자를 제외한 문자, 숫자, underscore( _ ), 달러 기호($)를 포함할 수 있다.<br>▪️단, 식별자는 특수문자를 제외한 문자, underscore( _ ),<br>▪️달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.<br>▪️예약어는 식별자로 사용할 수 없다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> first-name; <span class="comment">// SyntaxError: Unexpected token – (연산자로 평가됨)</span></span><br><span class="line"><span class="keyword">var</span> <span class="number">1</span>st;        <span class="comment">// SyntaxError: Invalid or unexpected token</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">this</span>;       <span class="comment">// SyntaxError: Unexpected token this</span></span><br></pre></td></tr></table></figure><hr><hr><br><p><strong>참고</strong>👏</p><ul><li><a href="https://poiemaweb.com/js-data-type-variable">PoiemaWeb - 데이터 타입과 변수</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://jimmyjoo.github.io/tags/javascript/"/>
    
    <category term="variable" scheme="https://jimmyjoo.github.io/tags/variable/"/>
    
    <category term="hoisting" scheme="https://jimmyjoo.github.io/tags/hoisting/"/>
    
    <category term="naming rules" scheme="https://jimmyjoo.github.io/tags/naming-rules/"/>
    
    <category term="poiemaweb" scheme="https://jimmyjoo.github.io/tags/poiemaweb/"/>
    
  </entry>
  
</feed>
