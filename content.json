{"pages":[],"posts":[{"title":"변수(Variable)란?","text":"하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름 식별자: 값이 아니라 메모리 주소를 기억. 즉, 매핑관계를 가지며 이 매핑정보도 메모리에 저장 변수선언(Declaration) 값을 저장하기 위한 메모리 공간 확보(allocate) 후 변수 이름과 메모리 주소 연결 확보 해제 전까지 메모리 공간 보호 12// 변수 선언문var name; 메모리 상에 공간을 확보하고 메모리 주소에 name(변수명)을 mapping해줌 선언 단계(Declaration phase): 변수 이름을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다. 초기화 단계(Initialization phase): 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당한다. 실행 컨텍스트(execution context): 자바스크립트 엔진이 소스 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역. 변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록됨. 변수 호이스팅(Variable Hoisting) 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징 123console.log(name); //undefinedvar name = 'Jimmy';console.log(name); //'Jimmy' 모든 선언문(declaration)은 런타임 이전 단계에서 실행됨 실행되면서 모든 값을 Undefined로 초기화 됨 따라서 reference error 발생되지 않고 undefined 출력 변수에 값 할당(Assignment)12var score; //변수 선언score = 10; //값 할당 초기화 당시에 undefined로 할당됨 그 이후에 새로운 값을 위해 메모리 공간을 확보하고 새로운 값을 저장하는 메모리 주소에 변수를 새롭게 mapping 따라서 값을 할당할 때도 사실상 재할당 1testScore = 100; // testScore가 선언되어있지 않음 선언되어 있지 않은 변수에 값을 할당하면 자바스크립트 엔진에 의해 전역변수의 property로 지정 변수에 값 재할당(Reassignment)12score = 10; //이미 score로 선언되었다고 가정score = 100; //100으로 재할당 원시값을 재할당 할 때 새로운 메모리 공간에 값을 재할당하고 변수를 그 주소로 새롭게 mapping해줍니다. 원시값은 변경불가능(immutable) ES6에서 새롭게 도입된 const 키워드와 헷갈리시면 안됩니다. const 키워드는 재할당 불가능을 의미하고 원시값은 변경이 불가능하다는 뜻입니다. 가비지 컬렉터(Garbage Collector):애플리케이션이 할당(allocate)한 메모리 공간을 주기적으로 검사하여 더 이상 사용되고 있지 않는 메모리를 해제(release). 더 이상 사용되고 있지 않는 메모리란 간단히 말하자면 어떤 식별자도 참조하고 있지 않는 메모리 공간을 의미. 자바스크립트는 가비지 컬렉터를 내장하고 있는 매니지드 언어이다. 이를 통해 메모리 누수(memory leak)를 방지 식별자 네이밍 규칙 식별자는 특수문자를 제외한 문자, 숫자, underscore( _ ), 달러 기호($)를 포함할 수 있다. 단, 식별자는 특수문자를 제외한 문자, underscore( _ ), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다. 예약어는 식별자로 사용할 수 없다. 123var first-name; // SyntaxError: Unexpected token – (연산자로 평가됨)var 1st; // SyntaxError: Invalid or unexpected tokenvar this; // SyntaxError: Unexpected token this 참고: [PoiemaWeb] https://poiemaweb.com","link":"/2020/07/03/js/Variable/"},{"title":"타입 변환과 단축 평가(Type Conversion)","text":"명시적 타입 변환(Explicit coercion) 암묵적 타입 변환(Implicit coercion) 기존 원시값을 직접 변경 X,(원시값은 변경 불가능이기 때문) 새로운 원시값 생성. 암묵적 타입 변환 같은 경우, 암묵적 타입 변환(Implicit Coercion) 타입 강제 변환(Type coercion) 표현식을 평가하는 도중에 JS엔진에 의해 암묵적으로 타입이 변환 새로운 값을 만들었다가 한번 사용하고 표현식의 평가가 끝나면 가비지 컬렉터에 의해서 메모리에서 해제 문자열 타입으로 변환 + 연산자 피연산자 중 하나 이상이 문자열일 경우 문자열 연결 연산자로 동작 123456789101 + '2'; // \"12\"console.log(`1 + 1 = ${1 + 1}`); // 1 + 1 = 20 + ''; // \"0\"false + ''; // \"false\"null + ''; // \"null\"undefined + ''; // undefinedSymbol() + ''; // TypeError(function () {} + ''); // \"function(){}\" 숫자 타입으로 변환 JS엔진이 산술 연산자나 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환 피연산자를 숫자로 변경할 수 없는 경우 평가결과 NaN 1234567891011121 - '1'; // 01 * '10'; // 101 / 'one' + // NaN'' + // 0'0' + // 0'1' + // 1'String' + // NaNnull + // 1undefined + // NaNSymbol() + // TypeError[] + // 0 function () {}; //NaN 불리언 타입으로 변환 JS엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환시킴 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분 Falsy값 false undefined null 0, -0 NaN ''(빈 문자열) Truthy값: Falsy 값 이외의 모든 값 명시적 타입 변환(Explicit Coercion) 타입 캐스팅(Type casting) 개발자가 의도적으로 값의 타입을 변환 문자열 타입으로 변환1234567891011121314// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법console.log(String(1)); // \"1\"console.log(String(NaN)); // \"NaN\"console.log(String(true)); // \"true\"// 2. Object.prototype.toString 메소드를 사용하는 방법console.log((1).toString()); // \"1\"console.log(NaN.toString()); // \"NaN\"console.log(true.toString()); // \"true\"// 3. 문자열 연결 연산자를 이용하는 방법console.log(1 + ''); // \"1\"console.log(NaN + ''); // \"NaN\"console.log(true + ''); // \"true\" 숫자 타입으로 변환1234567891011121314// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법console.log(Number('10.53')); // 10.53console.log(Number(false)); // 0// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)console.log(parseFloat('10.53')); // 10.53// 3. + 단항 산술 연산자를 이용하는 방법console.log(+'10.53'); // 10.53console.log(+false); // 0// 4. * 산술 연산자를 이용하는 방법console.log('10.53' * 1); // 10.53console.log(false * 1); // 0 불리언 타입으로 변환12345678910111213141516171819// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법console.log(Boolean('')); // falseconsole.log(Boolean('false')); // trueconsole.log(Boolean(1)); // trueconsole.log(Boolean(NaN)); // falseconsole.log(Boolean(Infinity)); // trueconsole.log(Boolean(null)); // falseconsole.log(Boolean(undefined)); // falseconsole.log(Boolean([])); // true// 2. ! 부정 논리 연산자를 두번 사용하는 방법console.log(!!''); // falseconsole.log(!!'false'); // trueconsole.log(!!1); // trueconsole.log(!!NaN); // falseconsole.log(!!Infinity); // trueconsole.log(!!null); // falseconsole.log(!!undefined); // falseconsole.log(!![]); // true 단축 평가(Short-Circuit Evaluation) 논리합(||) 연산자와 논리곱(&amp;&amp;) 연산자 표현식의 경가 결과는 불리언 값이 아닐 수도 있음 논리합(||), 논리곱(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가됨 단축평가 논리 연산의 결과를 결정한 타입 변환하지 않고 피연산자를 그대로 반환 표현식을 평가하는 도중에 평가 결과가 확정된 경우, 나머지 평가 과정을 중단 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 논리합(||) 연산자'Cat' || 'Dog'; // 'Cat'false || 'Dog'; // 'Dog''Cat' || false; // 'Cat'// 논리곱(&amp;&amp;) 연산자'Cat' &amp;&amp; 'Dog'; // Dogfalse &amp;&amp; 'Dog'; // false'Cat' &amp;&amp; false; // false// 논리곱(&amp;&amp;) 연산자 활용해 if문 대체 가능var done = true;var message = '';// 주어진 조건이 true일 때if (done) message = '완료';// if문은 단축 평가로 대체 가능하다.message = done &amp;&amp; '완료';console.log(message); // 완료// 객체가 null인지 확인하고 프로퍼티를 참조할 때var elem = null;console.log(elem.value); // TypeError: Cannot read property 'value' of nullconsole.log(elem &amp;&amp; elem.value); // null// 함수 매개변수에 기본값을 설정할 때// 단축 평가를 사용한 매개변수의 기본값 설정function getStringLength(str) { str = str || ''; return str.length;}getStringLength(); // 0getStringLength('hi'); // 2// ES6의 매개변수의 기본값 설정function getStringLength(str = '') { return str.length;}getStringLength(); // 0getStringLength('hi'); // 2","link":"/2020/07/04/js/TypeConversion/"}],"tags":[],"categories":[{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"study","slug":"javascript/study","link":"/categories/javascript/study/"}]}