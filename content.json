{"pages":[{"title":"About Me","text":"안녕하세요! 현재 FRONT-END 개발자가 되기 위해 공부하고 있습니다. 저는 여행을 좋아합니다.😁새로운 곳에서 다양한 경험을 통해 사고의 폭을 넓혀가는 여행은 저를 성장시켜줍니다.💪 개발 또한 여행이라 생각합니다. (✈️ = 💻)장소의 탐험이 아닌 기술의 탐험 🔎 이 블로그는 제 여행일지📕입니다. 아직 부족한 점이 많습니다.잘못된 부분이 있거나 논의가 필요한 부분은 댓글을 남겨주시면 감사하겠습니다. 🙏","link":"/about/index.html"}],"posts":[{"title":"🧐 변수(Variable)","text":"변수(Variable)의 정의와 필요성📍변수란 간단하게 말해서 상자다. 하나의 물건(값, 데이터)을 담고 저장할 수 있는 상자! 그렇다면 변수가 왜 필요한걸까? 기억하고 싶은 값을 메모리에 저장하고 안전하게(?) 재사용하기 위해서이다. 안전하게??🤔모든 값들은 메모리(메모리 셀의 집합)에 저장되어 있고 각각의 메모리 셀은 주소를 가지고 있다. 하지만 메모리 주소를 통해 값에 직접 접근하는 것은 치명적인 오류를 생산할 가능성이 존재하기 때문에 자바스크립트는 직접적인 메모리 제어를 허용하지 않는다. 재사용!🙂직접적인 메모리 제어를 허용한다 하더라도 재사용적인 측면에서 문제가 생긴다. 코드가 실행될 때 메모리의 상황에 따라 메모리 주소가 임의로 결정되기 때문에 값이 저장될 메모리 주소가 변경되어 재사용할 수 없다. 👉즉, 변수란 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이다. 식별자(Identifier)📍변수 이름을 식별자라고도 부른다. 식별자란 어떤 값을 구별하여 식별해낼 수 있는 고유한 이름이다. 따라서, 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별하여 식별해낼수 있어야 한다. 식별자는 값이 아니라 메모리 주소를 기억하고 있다. 값을 담고 있는 메모리 주소. 식별자는 메모리 주소에 붙인 이름이다. (🤨변수도 메모리 주소에 붙인 이름인데?? 뭐가 다른거야??)식별자가 변수를 포함하는 용어이다. 변수, 함수, 클래스 등의 모든 이름은 식별자다. 그리고 식별자는 네이밍 규칙을 준수해야하며, 선언(declaration)을 통해 자바스크립트 엔진에 식별자의 존재를 알린다. 변수선언(Declaration)📍변수를 사용하려면 먼저 변수를 생성해야한다. 변수 선언이란 쉽게 말해 변수를 생성하는 것이다.좀 더 구체적으로 말하자면 값을 저장하기 위한 메모리 공간 확보(allocate) 후 변수 이름과 메모리 주소 연결(mapping)한다. 확보 해제 전까지 메모리 공간 보호된다. 변수를 선언할 때는 var, let, const 키워드를 사용한다. 12// 변수 선언문var name; 변수 선언문은 2가지 단계를 거쳐 수행된다. 1️⃣선언 단계(Declaration phase)변수 이름을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다. 2️⃣초기화 단계(Initialization phase)값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당한다. (도대체 어디에 등록한다는거야?? 🤨)바로, 실행 컨텍스트(execution context)! 자바스크립트 엔진이 소스 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역.변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록된다. 변수 호이스팅(Variable Hoisting)📍변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징 12345console.log(name); //undefinedvar name = 'Jimmy';console.log(name); //'Jimmy' 호이스팅이 없었다면?변수 name을 선언하기 전에 console.log(name)을 통해 name을 참조하기 때문에 Reference Error가 발생해야 한다. 하지만, Reference Error 발생되지 않고 undefined가 출력된다. Why?? 바로 변수 호이스팅!모든 선언문은 런타임(코드가 한 줄씩 실행되는 시점) 이전 단계에서 실행된다.실행되면서 모든 값을 undefined로 초기화 된다. 사실 변수 선언뿐만이 아니라 함수, 클래스 선언문도 호이스팅된다. 변수에 값 할당(Assignment)📍123var score; //변수 선언score = 10; //값 할당 초기화 당시에 자바스크립트 엔진에 의해 undefined로 암묵적으로 할당된다. 그 이후에 새로운 값을 위해 메모리 공간을 확보하고 새로운 값을 저장하는 메모리 주소에 변수를 새롭게 mapping한다. 따라서, 엄밀히 말하자면 값을 할당할 때도 재할당된다. 1testScore = 100; // testScore가 선언되어있지 않음 선언되어 있지 않은 변수에 값을 할당하면 자바스크립트 엔진에 의해 전역변수(window객체)의 property로 지정된다. 변수에 값 재할당(Reassignment)📍12score = 10; //이미 score로 선언되었다고 가정score = 100; //100으로 재할당 원시값을 재할당 할 때 새로운 메모리 공간에 값을 재할당하고 변수를 그 주소로 새롭게 mapping해준다. 원시값은 변경불가능(immutable)! ES6에서 새롭게 도입된 const 키워드와 헷갈리지 말자! const 키워드는 재할당 불가능을 의미하고 원시값은 변경이 불가능하다는 뜻입니다. 식별자 네이밍 규칙📍▪️식별자는 특수문자를 제외한 문자, 숫자, underscore( _ ), 달러 기호($)를 포함할 수 있다.▪️단, 식별자는 특수문자를 제외한 문자, underscore( _ ),▪️달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.▪️예약어는 식별자로 사용할 수 없다. 123var first-name; // SyntaxError: Unexpected token – (연산자로 평가됨)var 1st; // SyntaxError: Invalid or unexpected tokenvar this; // SyntaxError: Unexpected token this 참고👏[PoiemaWeb] https://poiemaweb.com","link":"/2020/07/03/js/4.%20Variable/"},{"title":"제어문(Control Flow Statement)","text":"주어진 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용 일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다. 제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어 블록문(Block/Compound Statement) 0개 이상의 문을 중괄호로 묶은 것으로 코드 블록 자바스크립트는 블록문을 하나의 실행 단위로 취급 문의 끝에는 세미 콜론(;)을 붙이는 것이 일반적이지만 블록문의 끝에는 세미콜론을 붙이지 않는다 123456789101112131415161718// 블록문{ var foo = 10; console.log(foo);}// 제어문var x = 0;while (x &lt; 10) { x++;}console.log(x); // 10// 함수 선언문function sum(a, b) { return a + b;}console.log(sum(1, 2)); // 3 조건문(Conditional Statement) 주어진 조건식(conditional expression)의 평가 결과에 따라 코드 블럭(블록문)의 실행을 결정 조건식은 불리언 값으로 평가될 수 있는 표현식 코드 블록 내의 문이 하나뿐이라면 중괄호를 생략 가능 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768var num = 2;var kind;// if 문if (num &gt; 0) { kind = '양수'; // 음수를 구별할 수 없다}console.log(kind); // 양수// if…else 문if (num &gt; 0) { kind = '양수';} else { kind = '음수'; // 0은 음수가 아니다.}console.log(kind); // 양수// if…else if 문if (num &gt; 0) { kind = '양수';} else if (num &lt; 0) { kind = '음수';} else { kind = '영';}console.log(kind); // 양수//삼항 조건 연산자 사용var num = 2;// 0은 false로 취급된다.var kind = num ? (num &gt; 0 ? '양수' : '음수') : '영';console.log(kind); // 양수//switch문var year = 2000; // 2000년은 윤년으로 2월이 29일이다.var month = 2;var days = 0;switch (month) { case 1: case 3: case 5: case 7: case 8: case 10: case 12: days = 31; break; case 4: case 6: case 9: case 11: days = 30; break; case 2: // 윤년 계산 알고리즘 // 1. 년도가 4로 나누어 떨어지는 해는 윤년(2000, 2004, 2008, 2012, 2016, 2020…) // 2. 그 중에서 년도가 100으로 나누어 떨어지는 해는 평년(2000, 2100, 2200...) // 3. 그 중에서 년도가 400으로 나누어 떨어지는 해는 윤년(2000, 2400, 2800...) days = (year % 4 === 0 &amp;&amp; year % 100 !== 0) || year % 400 === 0 ? 29 : 28; break; default: console.log('Invalid month');}console.log(days); // 29 반복문(Loop Statement) 주어진 조건식의 평가 결과가 참인 경우 코드 블럭을 실행 그 후 조건식을 다시 검사하여 여전히 참인 경우 코드 블록을 다시 실행 조건식이 거짓일 때까지 반복 123456789101112131415161718192021222324// 중첩 for문for (var i = 1; i &lt;= 6; i++) { for (var j = 1; j &lt;= 6; j++) { if (i + j === 6) console.log(`[${i}, ${j}]`); }}// while문var count = 0;// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.while (count &lt; 3) { console.log(count); count++;} // 0 1 2// do...while문 (최소 한번 실행)var count = 0;// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.do { console.log(count); count++;} while (count &lt; 3); // 0 1 2 break문(Break Statement) 레이블 문, 반복문(for, for…in, for…of, while, do…while) 또는 switch 문의 코드 블록을 탈출 1234567891011121314151617181920212223242526272829303132if (true) { break; // Uncaught SyntaxError: Illegal break statement}// outer라는 식별자가 붙은 레이블 for 문outer: for (var i = 0; i &lt; 3; i++) { for (var j = 0; j &lt; 3; j++) { // i + j === 3이면 outer라는 식별자가 붙은 레이블 for 문을 탈출한다. if (i + j === 3) break outer; console.log('inner ' + j); }}console.log('Done!');// break문 예제var string = 'Hello World.';var search = 'l';var index;// 문자열은 유사배열이므로 for 문으로 순회할 수 있다.for (var i = 0; i &lt; string.length; i++) { // 문자열의 개별 문자가 'l'이면 if (string[i] === search) { index = i; break; // 반복문을 탈출한다. }}console.log(index); // 2// 참고로 String.prototype.indexOf 메소드를 사용해도 같은 동작을 한다.console.log(string.indexOf(search)); // 2 continue문(Continue Statement) continue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 이동 break 문처럼 반복문을 탈출하지는 않음 12345678910111213141516var string = 'Hello World.';var search = 'l';var count = 0;// 문자열은 유사배열이므로 for 문으로 순회할 수 있다.for (var i = 0; i &lt; string.length; i++) { // 'l'이 아니면 현 지점에서 실행을 중단하고 반복문의 증감식으로 이동한다. if (string[i] !== search) continue; count++; // continue 문이 실행되면 이 문은 실행되지 않는다.}console.log(count); // 3// 참고로 String.prototype.match 메소드를 사용해도 같은 동작을 한다.const regexp = new RegExp(search, 'g');console.log(string.match(regexp).length); // 3 참고: [PoiemaWeb] https://poiemaweb.com","link":"/2020/07/09/js/8.%20ControlFlowStatement/"},{"title":"🤔 데이터 타입(Data Type)","text":"원시타입, 객체타입 테이터 타입은 데이터를 메모리에 저장할 때 확보해야 하는 메모리 공간의 크기와 할당할 수 있는 유효한 값에 대한 정보, 그리고 메모리에 저장되어 있는 2진수 데이터를 어떻게 해석할 지에 대한 정보를 제공 원시타입(Primitive Data Type)▪️number▪️string▪️boolean▪️null▪️undefined▪️symbol (ES6에서 추가되었다.) 숫자(number)자바스크립트에서 number는 모두 실수로 처리된다.하나의 숫자 타입(정수X, 실수)만 존재 8 bytes 1234567// 모두 실수로 처리됨var num = 7 / 2;console.log(num) = 3.5; //출력값: 3.5console.log(10 / 0); // Infinityconsole.log(10 / -10); // -Infinityconsole.log(1 * 'String'); // NaN(Not-a-Number) 문자열(string) 0개 이상의 16bit 유니코드 문자(UTF-16)들의 집합 한 번 정의된 문자열은 변경 불가능(immutable) 배열처럼 인덱스를 통해 접근 가능 -&gt; 유사 배열 123var str = 'hello';str[0] = 'H';console.log(str); //출력값: 'hello' 새로운 문자열을 재할당하는 것은 가능(기존 문자열을 변경하는 것이 아니라 새로운 문자열을 새롭게 할당하는 것) 1234var str = 'hello';console.log(str); // 'hello'str += 'Jimmy';console.log(str); // 'helloJimmy' 템플릿 리터럴 ES6부터 도입된 새로운 문자열 표기법 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 여러가지의 편리한 문자열 처리 기능 제공 런타임에 일반 문자열로 변환되어 처리됨 백틱(``)사용 123456789// 멀티라인 문자열var template = `&lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Home&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;`;// 표현식 삽입var first = 'Jimmy';var last = 'Joo';console.log(`My name is ${first} ${last}.`); 불리언(boolean) true, false(0, 비어있는 문자열, null, undefined) undefined(undefined) 선언 이후 값을 할당하지 않은 변수의 값: undefined 변수 선언에 의해 확보된 메모리 공간을 처음 할당할 때 자바스크립트 엔진이 값을 undefined로 초기화 시킴 null(null) 의도적으로 변수에 값이 없다는 것을 명시 함수가 호출되었으나 유효한 값을 반환할 수 없는 경우, 명시적으로 null 반환 typeof로 확인하면 object나옴(자바스크립트 설계상 오류 -&gt; 일치연산자(===) 사용해서 확인할것) symbol(symbol) 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키(property key)를 만들기 위해 사용 Symbol함수를 호출해 생성 1var key = Symbol('key'); 객체 타입(Object/Reference Data Type) object 객체(object): 데이터(property)와 그 데이터에 관련한 동작(method)을 모두 포함할 수 있는 독립적 주체 자바스크립트를 이루고 있는 거의 ‘모든 것’이 객체 원시 타입을 제외한 나머지 값들(배열, 함수, 정규표현식 등)은 모두 객체 잠초에 의한 전달(pass-by-reference) 데이터 타입의 필요성 데이터 타입에 의한 메모리 공간의 확보와 참조 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정(e.g. 숫자타입 =&gt; 8byte) 값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정 데이터 타입에 의한 값의 해석 메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정 동적 타이핑 정적 타입(Static/Strong type) 언어: e.g. C, C++, Java 변수를 선언할 때 데이터 타입 선언 컴파일 시점에 타입 체크 타입의 일관성을 강제하여 보다 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄임 동적 타입(Dynamic/Weak type) 언어: e.g. JavaScript 값을 할당하는 시점에 변수의 타입이 동적으로 결정됨 재할당에 의해 변수의 타입을 언제든지 자유롭게 변경 가능 단점: 변화하는 변수 값 추적하기 어려움. 신뢰성 떨어짐 주의사항: 필요한 경우에 한해 제한적으로 사용 유효 범위(스코프)는 최대한 좁게 전역 변수는 지양 변수보다는 상수를 사용해 값의 변경 억제 명확하고 구체적인 변수명 네이밍 참고: [PoiemaWeb] https://poiemaweb.com","link":"/2020/07/05/js/6.%20DataType/"},{"title":"원시 값과 객체의 비교","text":"원시타입 객체타입 값 변경여부 변경 불가능 변경 가능 저장되는 값 실제 값 저장 참조 값 저장 전달방식 값에 의한 전달(Pass by Value) 참조에 의한 전달(Pass by Reference) 원시 값 변경 불가능 한 값(immutable) 변수 값은 변경 가능: 재할당에 의해서 값 자체는 변경 불가능(read-only) 문자열과 불변성 자바스크립트에서 문자열은 원시타입 -&gt; 변경 불가능 1234567var str = 'Hello';str = 'world!'; // 새로운 메모리 공간 확보 -&gt; 식별자 str는 'world!'를 가르킴str[0] = 'S'; // 원시값이기 때문에 변하지 않음. 에러발생 Xconsole.log(str); // -&gt; 'world!' 값에 의한 전달(Pass by Value) 1234567891011121314var score = 80;// 변수 copy에는 변수 score의 값 80이 복사되어 할당된다.var copy = score;console.log(score, copy); // 80 80console.log(score === copy); // true// 변수 score와 변수 copy의 값은 다른 메모리 공간에 저장된 별개의 값이다.// 따라서 변수 score의 값을 변경하여도 변수 copy의 값에는 어떠한 영향도 주지 않는다.score = 100;console.log(score, copy); // 100 80console.log(score === copy); // false 객체 프로퍼티 동적 추가/삭제 가능 변경 가능 한 값(mutable) 재할당 없이 객체를 직접 변경 가능 얕은 복사(shallow copy) 12345678910111213var person = { name: 'Lee',};// 프로퍼티 값 갱신person.name = 'Kim';// 프로퍼티 동적 생성person.address = 'Seoul';console.log(person); // {name: \"Kim\", address: \"Seoul\"}var newPerson = person; // shallow copy 참조에 의한 전달(Pass by Reference) 객체를 가르키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달 이렇게 될 경우, 두 변수 모두 같은 주소값을 가르킴 둘 중 한 객체가 변경될 경우, 다른 객체도 영향을 받음 1234567891011121314151617181920var person = { name: 'Jimmy',};// 참조 값을 복사. copy와 person은 동일한 참조 값을 갖는다.var copy = person;// copy와 person은 동일한 객체를 참조한다.console.log(copy === person); // true// copy를 통해 객체를 변경한다.copy.name = 'Joo';// person을 통해 객체를 변경한다.person.address = 'Seoul';// copy와 person은 동일한 객체를 가리키고 있다.// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.console.log(person); // {name: \"Joo\", address: \"Seoul\"}console.log(copy); // {name: \"Joo\", address: \"Seoul\"} 참고: [PoiemaWeb] https://poiemaweb.com","link":"/2020/07/15/js/11.%20TypeComparison/"},{"title":"🤓 표현식과 문(Expression &amp; Statement)","text":"값(Value)📍👉 식(표현식, Expression)이 평가(Evaluate)되어 생성된 결과 12345// 1+2라는 식이 평가되어 3이라는 숫자값을 생성1 + 2; // 3// sum이라는 변수에 1 + 2 라는 식이 평가되어 생성된 3이라는 숫자값을 할당var sum = 1 + 2; 값은 다양한 방법으로 생성할 수 있다.그 중에서 가장 기본적인 방법은 리터럴을 생성하는 것이다. 리터럴(Literal)📍👉 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기 방식 JS엔진이 런타임에 리터럴을 평가하여 값을 생성한다. 1234567893 // 정수 리터럴'Hello' // 문자열 리터럴true // 불리언 리터럴null // null 리터럴undefined // undefined 리터럴{ name : 'Jimmy'} // 객체 리터럴[1,2] // 배열 리터럴function() {} // 함수 리터럴/^[0-9]+$/ // 정규 표현식 리터럴 표현식(Expression)📍👉 값으로 평가될 수 있는 문(Statement) 표현식이 평가되면 값을 생성하거나 값을 참조한다.리터럴은 값으로 평가되기 때문에 리터럴도 표현식이다. 1234567891011121314151617// 리터럴 표현식(JS엔진에 의해 런타임에 평가되어 값 생성 =&gt; 표현식)100;('Jimmy');// 식별자 표현식(식별자 참조)var sum = 50;sum; // -&gt; 변수 sum에 100이라는 값이 할당되어 있다면 참조를 통해 값(100)이 평가됨 =&gt; 표현식person.name;// 연산자 표현식10 + 20;sum = 10;sum === 10; // true라는 값을 생성// 함수/메소드 호출 표현식getSum();person.getAge(); 표현식과 표현식이 평가된 값은 동치(equivalent)이다. 즉, 표현식을 값처럼 사용 가능 → 값이 위치할 수 있는 자리에 표현식도 위치할 수 있다. (e.g. 변수에 지정 가능) 문(Statement)📍👉 프로그램을 구성하는 기본 단위이자 최소 실행 단위 쉽게 말해 컴퓨터에 내리는 명령이다.그리고 문들은 토큰(token) 들로 구성되어있다. 토큰이란 문법적인 의미를 가지며, 문법적으로 더이상 나눌 수 없는 코드의 기본 요소를 말한다.예를 들어, 키워드, 식별자, 연산자, 리터럴, 세미콜론, 마침표 등이 있다. 1var product = 4 * 5; 문에는 여러 종류가 있다.대표적으로 선언문, 할당문, 조건문, 반복문으로 구분할 수 있다. 12345678910111213141516// 선언문var name;function getName() {}// 할당문name = 'Jimmy';// 조건문if (score &gt;= 90) { console.log('Your grade is A');}// 반복문for (var i = 0; i &lt; 10; i++) { console.log(i);} 세미콜론(Semicolon)📍세미콜론(;)은 문(statement)의 종료를 나타낸다. 따라서 문은 세미콜론으로 끝나야 한다.단, 0개 이상의 문을 중괄호({ })로 묶은 코드블록 뒤에는 붙이지 않는다. (e.g. if문, for문, 함수) 하지만, 세미콜론을 붙이는 것은 옵션!이다. 그 것은 바로 세미콜론 자동 삽입 기능(ASI, Automatic Semicolon Insertion) 때문이다.이 기능은 JS엔진이 코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여준다. ❗️문제점: 개발자의 의도와 다를수 있다. 표현식인 문과 표현식이 아닌 문📍표현식과 문의 개념을 헷갈리지 말자.🤯 문에는 표현식인 문과 표현식이 아닌 문이 있다.표현식인 문은 값으로 평가될 수 있는 문이다.표현식이 아닌 문은 값으로 평가될 수 없다. 간단하게 구분하는 방법이 있다.바로 변수에 할당하기!😎 표현식인 문은 값으로 평가되므로 변수에 할당이 가능하다.반대의 경우 에러🚫가 발생한다. 1234567// 선언문 =&gt; 값 평가 X, 즉 표현식이 아닌 문var x;var y = var x; // SyntaxError// 할당문 =&gt; 값으로 평가됨 =&gt; 표현식인 문x = 100;var y = x = 100; // x에 100 할당되고 y에 x의 값(100)이 할당됨 크롬 개발자 도구에서 표현식이 아닌 문은 언제나 undefined를 출력한다. 참고👏[PoiemaWeb] https://poiemaweb.com","link":"/2020/07/04/js/5.%20Expression&Statement/"},{"title":"타입 변환과 단축 평가(Type Conversion)","text":"명시적 타입 변환(Explicit coercion) 암묵적 타입 변환(Implicit coercion) 기존 원시값을 직접 변경 X,(원시값은 변경 불가능이기 때문) 새로운 원시값 생성. 암묵적 타입 변환 같은 경우, 암묵적 타입 변환(Implicit Coercion) 타입 강제 변환(Type coercion) 표현식을 평가하는 도중에 JS엔진에 의해 암묵적으로 타입이 변환 새로운 값을 만들었다가 한번 사용하고 표현식의 평가가 끝나면 가비지 컬렉터에 의해서 메모리에서 해제 문자열 타입으로 변환 + 연산자 피연산자 중 하나 이상이 문자열일 경우 문자열 연결 연산자로 동작 123456789101 + '2'; // \"12\"console.log(`1 + 1 = ${1 + 1}`); // 1 + 1 = 20 + ''; // \"0\"false + ''; // \"false\"null + ''; // \"null\"undefined + ''; // undefinedSymbol() + ''; // TypeError(function () {} + ''); // \"function(){}\" 숫자 타입으로 변환 JS엔진이 산술 연산자나 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환 피연산자를 숫자로 변경할 수 없는 경우 평가결과 NaN 1234567891011121 - '1'; // 01 * '10'; // 101 / 'one' + // NaN'' + // 0'0' + // 0'1' + // 1'String' + // NaNnull + // 1undefined + // NaNSymbol() + // TypeError[] + // 0 function () {}; //NaN 불리언 타입으로 변환 JS엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환시킴 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분 Falsy값 false undefined null 0, -0 NaN ''(빈 문자열) Truthy값: Falsy 값 이외의 모든 값 명시적 타입 변환(Explicit Coercion) 타입 캐스팅(Type casting) 개발자가 의도적으로 값의 타입을 변환 문자열 타입으로 변환1234567891011121314// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법console.log(String(1)); // \"1\"console.log(String(NaN)); // \"NaN\"console.log(String(true)); // \"true\"// 2. Object.prototype.toString 메소드를 사용하는 방법console.log((1).toString()); // \"1\"console.log(NaN.toString()); // \"NaN\"console.log(true.toString()); // \"true\"// 3. 문자열 연결 연산자를 이용하는 방법console.log(1 + ''); // \"1\"console.log(NaN + ''); // \"NaN\"console.log(true + ''); // \"true\" 숫자 타입으로 변환1234567891011121314// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법console.log(Number('10.53')); // 10.53console.log(Number(false)); // 0// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)console.log(parseFloat('10.53')); // 10.53// 3. + 단항 산술 연산자를 이용하는 방법console.log(+'10.53'); // 10.53console.log(+false); // 0// 4. * 산술 연산자를 이용하는 방법console.log('10.53' * 1); // 10.53console.log(false * 1); // 0 불리언 타입으로 변환12345678910111213141516171819// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법console.log(Boolean('')); // falseconsole.log(Boolean('false')); // trueconsole.log(Boolean(1)); // trueconsole.log(Boolean(NaN)); // falseconsole.log(Boolean(Infinity)); // trueconsole.log(Boolean(null)); // falseconsole.log(Boolean(undefined)); // falseconsole.log(Boolean([])); // true// 2. ! 부정 논리 연산자를 두번 사용하는 방법console.log(!!''); // falseconsole.log(!!'false'); // trueconsole.log(!!1); // trueconsole.log(!!NaN); // falseconsole.log(!!Infinity); // trueconsole.log(!!null); // falseconsole.log(!!undefined); // falseconsole.log(!![]); // true 단축 평가(Short-Circuit Evaluation) 논리합(||) 연산자와 논리곱(&amp;&amp;) 연산자 표현식의 경가 결과는 불리언 값이 아닐 수도 있음 논리합(||), 논리곱(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가됨 단축평가 논리 연산의 결과를 결정한 타입 변환하지 않고 피연산자를 그대로 반환 표현식을 평가하는 도중에 평가 결과가 확정된 경우, 나머지 평가 과정을 중단 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 논리합(||) 연산자'Cat' || 'Dog'; // 'Cat'false || 'Dog'; // 'Dog''Cat' || false; // 'Cat'// 논리곱(&amp;&amp;) 연산자'Cat' &amp;&amp; 'Dog'; // Dogfalse &amp;&amp; 'Dog'; // false'Cat' &amp;&amp; false; // false// 논리곱(&amp;&amp;) 연산자 활용해 if문 대체 가능var done = true;var message = '';// 주어진 조건이 true일 때if (done) message = '완료';// if문은 단축 평가로 대체 가능하다.message = done &amp;&amp; '완료';console.log(message); // 완료// 객체가 null인지 확인하고 프로퍼티를 참조할 때var elem = null;console.log(elem.value); // TypeError: Cannot read property 'value' of nullconsole.log(elem &amp;&amp; elem.value); // null// 함수 매개변수에 기본값을 설정할 때// 단축 평가를 사용한 매개변수의 기본값 설정function getStringLength(str) { str = str || ''; return str.length;}getStringLength(); // 0getStringLength('hi'); // 2// ES6의 매개변수의 기본값 설정function getStringLength(str = '') { return str.length;}getStringLength(); // 0getStringLength('hi'); // 2 참고: [PoiemaWeb] https://poiemaweb.com","link":"/2020/07/11/js/9.%20TypeConversion/"},{"title":"연산자(Operator)","text":"연산자(Operator): 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산(operation) 등을 수행해 하나의 값을 만든다. 산수 연산자(Arithmetic Operator) 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 생성. 산술 연산이 불가능한 경우, NaN을 반환 이항 산수 연산자 피연산자 2개, 부수효과 X +(덧셈), -(뺄셈), *(곱셈), /(나눗셈), %(나머지) 단항 산수 연산자 피연산자 1개 ++(증가, 부수효과), --(감소, 부수효과), +, - 12345678910111213141516// '+' 연산자는 숫자타입이 아닌 피연산자를 숫자로 타입 변환한다.// 아무런 효과가 없다.+10; // -&gt; 10+-10; // -&gt; -10// 문자열을 숫자로 타입 변환한다.+'10'; // -&gt; 10// 불리언 값을 숫자로 타입 변환한다.+true; // -&gt; 1// 불리언 값을 숫자로 타입 변환한다.+false; // -&gt; 0// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.+'Hello'; // -&gt; NaN 문자열 연결 연산자 +연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작 1234567891011// 문자열 연결 연산자'1' + 2; // '12'// 타입변환1 + true; // 2(1 + 1)1 + false; // 1(false = 0)1 + null; // 1(null = 0)// undefined는 숫자로 타입 변환되지 않는다+undefined; // NaN1 + undefined; //NaN 할당 연산자(Assignment Operator) 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당 부수효과 O 123456789101112131415161718192021222324252627282930313233343536x = 10;console.log(x); // 10x += 5; // x = x + 5;console.log(x); // 15x -= 5; // x = x - 5;console.log(x); // 10x *= 5; // x = x * 5;console.log(x); // 50x /= 5; // x = x / 5;console.log(x); // 10x %= 5; // x = x % 5;console.log(x); // 0var str = 'My name is ';// 문자열 연결 연산자str += 'Lee'; // str = str + 'Lee';console.log(str); // 'My name is Lee'// 할당문은 표현식인 문이다.console.log((x = 10)); // 10var a, b, c;// 연쇄 할당. 오른쪽에서 왼쪽으로 진행.// ① c = 0 : 0으로 평가된다// ② b = 0 : 0으로 평가된다// ③ a = 0 : 0으로 평가된다a = b = c = 0;console.log(a, b, c); // 0 0 0 비교 연산자(Comparison Operator) 동등(loose) / 일치(strict) 비교 연산자 동등 비교(==): 암묵적 타입 변환을 통해 타입을 일치시킨 후, 같은 값인지 비교 일치 비교(===): 타입도 같고 값도 같은 경우에 한하여 true를 반환 +(덧셈), -(뺄셈), *(곱셈), /(나눗셈), %(나머지) 1234567891011121314// 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 동등하다.5 == '5'; // -&gt; true// 동등 비교. 결과를 예측하기 어렵다.'0' == ''; // -&gt; false0 == ''; // -&gt; true0 == '0'; // -&gt; truefalse == 'false'; // -&gt; falsefalse == '0'; // -&gt; truefalse == null; // -&gt; falsefalse == undefined; // -&gt; false// NaN은 자신과 일치하지 않는 유일한 값이다.NaN === NaN; // -&gt; false // 빌트인 함수 isNaN은 주어진 값이 NaN인지 체크하고 그 결과를 반환한다. isNaN(NaN); // -&gt; true isNaN(10); // -&gt; false isNaN(1 + undefined); // -&gt; true //ES6 Object.is method Object.is(-0, +0); // -&gt; false Object.is(NaN, NaN); // -&gt; true 1234567891011## **비교 연산자**(Comparison Operator)- 피연산자의 크기를 비교하여 불리언 값을 반환```javascript// 대소 관계 비교5 &gt; 0; // -&gt; true5 &gt; 5; // -&gt; false5 &gt;= 5; // -&gt; true5 &lt;= 5; // -&gt; true 비교 연산자(Ternary Operator) 조건식의 평가 결과에 따라 반환할 값을 결정 자바스크립트의 유일한 삼항 연산자이며 부수 효과 X 12345var x = 10;// 삼항 연산자 표현식은 표현식인 문이다. 따라서 값처럼 사용할 수 있다.var result = x % 2 ? '홀수' : '짝수';console.log(result); // 짝수 논리 연산자(Logical Operator) 우항과 좌항의 피연산자(부정 논리 연산자의 경우, 우항의 피연산자)를 논리 연산 부수 효과 X ||(OR, 논리합), &amp;&amp;(AND, 논리곱), !(NOT, 부정) 논리합(||) 또는 논리곱(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 어는 한쪽으로 평가 123456// 암묵적 타입 변환!0; // -&gt; true!'Hello'; // -&gt; false// 단축 평가'Cat' &amp;&amp; 'Dog'; // -&gt; 'Dog' 쉼표 연산자 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환 123var x, y, z;(x = 1), (y = 2), (z = 3); // 3 그룹 연산자 그룹 연산자를 사용하면 연산자의 우선 순위를 조절 12// 그룹 연산자를 사용하여 우선 순위 조절10 * (2 + 3); // -&gt; 50 typeof 연산자 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환 123var x, y, z;(x = 1), (y = 2), (z = 3); // 3 그룹 연산자 typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환 7가지 문자열 “string”, “number”, “boolean”, “undefined”, “symbol”, “object”, “function” 중 하나를 반환 null 타입을 확인할 때는 typeof 연산자를 사용하지 말고 일치 연산자(===)를 사용 선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 “undefined”를 반환 123456789101112131415typeof ''; // -&gt; \"string\"typeof 1; // -&gt; \"number\"typeof NaN; // -&gt; \"number\"typeof true; // -&gt; \"boolean\"typeof undefined; // -&gt; \"undefined\"typeof Symbol(); // -&gt; \"symbol\"typeof null; // -&gt; \"object\"typeof []; // -&gt; \"object\"typeof {}; // -&gt; \"object\"typeof new Date(); // -&gt; \"object\"typeof /test/gi; // -&gt; \"object\"typeof function () {}; // -&gt; \"function\"// 식별자 undeclared는 선언한 적이 없다.typeof undeclared; // -&gt; undefined 지수 연산자 ES7부터 도입 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 타입의 값을 반환 음수를 거듭제곱의 밑으로 계산하려면 아래와 같이 괄호로 묶어야 한다 12345678910111213142 ** 2; // -&gt; 42 ** 2.5; // -&gt; 5.656854249492382 ** 0; // -&gt; 12 ** -2; // -&gt; 0.25(-5) ** 2; // -&gt; 25var num = 5;num **= 2; // -&gt; 25//ES7 이전Math.pow(2, 2); // -&gt; 4Math.pow(2, 2.5); // -&gt; 5.65685424949238Math.pow(2, 0); // -&gt; 1Math.pow(2, -2); // -&gt; 0.25 연산자의 부수 효과 할당(=) 연산자, 증가/감소(++/–) 연산자, delete 연산자 123456789101112131415161718var x;// 할당 연산자는 변수 값이 변하는 부수 효과가 있다.// 이는 변수 x를 사용하는 다른 코드에 영향을 준다.x = 1;console.log(x); // 1// 증가/감소(++/--) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다.// 피연산자 x의 값이 변경된다. 이는 변수 x를 사용하는 다른 코드에 영향을 준다.x++;console.log(x); // 2var o = { a: 1 };// delete 연산자는 객체의 프로퍼티를 삭제하는 부수 효과가 있다.// 이는 객체 o를 사용하는 다른 코드에 영향을 준다.delete o.a;console.log(o); // {} 참고: [PoiemaWeb] https://poiemaweb.com","link":"/2020/07/08/js/7.%20Operator/"},{"title":"객체 리터럴(Object Literal)","text":"객체(Object) 원시 값을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체 객체 타입(object / reference type)은 다양한 타입의 값(원시 값 또는 다른 객체)들을 하나의 단위로 구성한 복합적인 자료 구조(Data structure) 변경 가능한 값(mutable value) 키(key)과 값(value)으로 구성된 프로퍼티(Property)들의 집합 프로퍼티: 객체의 상태를 나타내는 값 메소드: 프로퍼티를 참조하고 조작할 수 있는 동작 객체 리터럴에 의한 객체 생성 중괄호({...}) 내에 0개 이상의 프로퍼티를 정의 변수에 할당이 이루어지는 시점에 JS엔진이 객체 리터럴을 해석하여 객체를 생성 객체 리터럴의 중괄호는 코드 블록 의미 X 객체 리터럴은 값으로 평가되는 표현식 -&gt; 닫는 중괄호 뒤에 세미콜론 12345678910// 객체 생성var person = { name: 'Joo'; // 프로퍼티 sayHello: function() { // 메소드 console.log(`Hello! My name is ${this.name}.`); }};// 빈 객체 생성var emptyObject = {}; 프로퍼티(Property) 키(key)과 값(value)으로 구성 나열할 때 쉼표(,)로 구분 (마지막 프로퍼티 뒤에는 쉼표는 옵션) 프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 symbol값 식별자 네이밍 규칙 따르면 따옴표 생략 가능 반대로 따르지 않으면 따옴표 필수 프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값 프로퍼티 Cascading됨(같은 이름일 경우 나중에 실행된 프로퍼티가 덮어씀) 메소드(Method) 객체에 제한되어 있는 함수 123456var person = { name: 'Joo'; sayName(): function() { // 메소드 console.log('Hi! My name is ' + this.name); }} 프로퍼티 접근 마침표 표기법(Dot notation) 대괄호 표기법(Bracket notation) 반드시 따옴표로 감싼 문자열 감싸지 않으면 식별자로 해석됨 123456789101112131415161718192021222324252627var person = { name: 'Joo'; 'first-name': 'Jimmy'; 10: 100;};// 마침표 표기법에 의한 프로퍼티 접근console.log(person.name); // Joo// 대괄호 표기법에 의한 프로퍼티 접근console.log(person['name']); // Jooconsole.log(person[name]); // ReferenceError: name is not defined// 존재하지 않는 프로퍼티 접근console.log(person.age); // undefined(not Reference Error)// 프로퍼티 키가 유효하지 않은 이름일 경우 -&gt; 대괄호 사용!console.log(person.'first-name'); // SyntaxErrorconsole.log(person.first-name); // ReferenceErrorconsole.log(person[first-name]); // ReferenceErrorconsole.log(person['first-name']); // Jimmy//프로퍼티 키가 숫자로 이루어진 문자열일 경우console.log(person.10); // SyntaxErrorconsole.log(person.'1'); // SyntaxErrorconsole.log(person[1]); // 10console.log(person['1']); // 10 프로퍼티 값 갱신/생성/삭제123456789101112131415var person = { name: 'Jimmy';};// name 값 갱신person.name = 'Joo';console.log(person.name); // Joo// 프로퍼티 생성(해당 프로퍼티 존재하지 않을경우 생성, 존재할 경우 갱신)person.age = 27;console.log(person); {name: 'Joo', age: 27};// 존재하는 프로퍼티 삭제, 존재하지 않을 경우 무시(에러X)delete person.age;delete person.height; // 무시됨 ES6에서 추가된 객체 리터럴의 확장 기능 프로퍼티 축약 표현 프로퍼티 값으로 변수를 사용하는 경우, 변수 이름과 프로퍼티 키가 동일한 이름일 때, 프로퍼티 키를 생략 가능 12345var firstName = 'Jimmy';var lastName = 'Joo';const obj = { firstName, lastName };console.log(obj); // {firstName: 'Jimmy', lastName: 'Joo'} 프로퍼티 키 동적 생성 객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성 가능(그 전에는 외부에서만 가능) 123456789const prefix = 'prop';let i = 0;var obj = { [`${prefix}-${++i}`]: i, [`${prefix}-${++i}`]: i, [`${prefix}-${++i}`]: i,};console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3} 메소드 축약 표현 메소드 정의할 때, function 키워드를 생략 가능javascript const obj = { name: 'Joo'; sayHi() { console.log('Hi! My name is' + this.name); } }; obj.sayHi(); // Hi! My name is Joo 참고: [PoiemaWeb] https://poiemaweb.com","link":"/2020/07/12/js/10.%20ObjectLiteral/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"variable","slug":"variable","link":"/tags/variable/"},{"name":"hoisting","slug":"hoisting","link":"/tags/hoisting/"},{"name":"naming rules","slug":"naming-rules","link":"/tags/naming-rules/"},{"name":"expression","slug":"expression","link":"/tags/expression/"},{"name":"statement","slug":"statement","link":"/tags/statement/"},{"name":"data type","slug":"data-type","link":"/tags/data-type/"},{"name":"operator","slug":"operator","link":"/tags/operator/"},{"name":"control flow","slug":"control-flow","link":"/tags/control-flow/"},{"name":"type conversion","slug":"type-conversion","link":"/tags/type-conversion/"},{"name":"object","slug":"object","link":"/tags/object/"},{"name":"property","slug":"property","link":"/tags/property/"},{"name":"method","slug":"method","link":"/tags/method/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"pass-by-value","slug":"pass-by-value","link":"/tags/pass-by-value/"},{"name":"pass-by-reference","slug":"pass-by-reference","link":"/tags/pass-by-reference/"},{"name":"poiemaweb","slug":"poiemaweb","link":"/tags/poiemaweb/"}],"categories":[{"name":"javascript","slug":"javascript","link":"/categories/javascript/"}]}