{"pages":[{"title":"About Me","text":"안녕하세요! 현재 FRONT-END 개발자가 되기 위해 공부하고 있습니다. 저는 여행을 좋아합니다.😁새로운 곳에서 다양한 경험을 통해 사고의 폭을 넓혀가는 여행은 저를 성장시켜줍니다.💪 개발 또한 여행이라 생각합니다. (✈️ = 💻)장소의 탐험이 아닌 기술의 탐험 🔎 이 블로그는 제 여행일지📕입니다. 아직 부족한 점이 많습니다.잘못된 부분이 있거나 논의가 필요한 부분은 댓글을 남겨주시면 감사하겠습니다. 🙏","link":"/about/index.html"}],"posts":[{"title":"변수(Variable)","text":"변수(Variable)의 정의와 필요성📍변수란 간단하게 말해서 상자다. 하나의 물건(값, 데이터)을 담고 저장할 수 있는 상자! 그렇다면 변수가 왜 필요한걸까? 기억하고 싶은 값을 메모리에 저장하고 안전하게(?) 재사용하기 위해서이다. 안전하게??🤔모든 값들은 메모리(메모리 셀의 집합)에 저장되어 있고 각각의 메모리 셀은 주소를 가지고 있다. 하지만 메모리 주소를 통해 값에 직접 접근하는 것은 치명적인 오류를 생산할 가능성이 존재하기 때문에 자바스크립트는 직접적인 메모리 제어를 허용하지 않는다. 재사용!🙂직접적인 메모리 제어를 허용한다 하더라도 재사용적인 측면에서 문제가 생긴다. 코드가 실행될 때 메모리의 상황에 따라 메모리 주소가 임의로 결정되기 때문에 값이 저장될 메모리 주소가 변경되어 재사용할 수 없다. 👉즉, 변수란 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이다. 식별자(Identifier)📍변수 이름을 식별자라고도 부른다. 식별자란 어떤 값을 구별하여 식별해낼 수 있는 고유한 이름이다. 따라서, 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별하여 식별해낼수 있어야 한다. 식별자는 값이 아니라 메모리 주소를 기억하고 있다. 값을 담고 있는 메모리 주소. 식별자는 메모리 주소에 붙인 이름이다. (🤨변수도 메모리 주소에 붙인 이름인데?? 뭐가 다른거야??)식별자가 변수를 포함하는 용어이다. 변수, 함수, 클래스 등의 모든 이름은 식별자다. 그리고 식별자는 네이밍 규칙을 준수해야하며, 선언(declaration)을 통해 자바스크립트 엔진에 식별자의 존재를 알린다. 변수선언(Declaration)📍변수를 사용하려면 먼저 변수를 생성해야한다. 변수 선언이란 쉽게 말해 변수를 생성하는 것이다.좀 더 구체적으로 말하자면 값을 저장하기 위한 메모리 공간 확보(allocate) 후 변수 이름과 메모리 주소 연결(mapping)한다. 확보 해제 전까지 메모리 공간 보호된다. 변수를 선언할 때는 var, let, const 키워드를 사용한다. 12// 변수 선언문var name; 변수 선언문은 2가지 단계를 거쳐 수행된다. 1️⃣선언 단계(Declaration phase)변수 이름을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다. 2️⃣초기화 단계(Initialization phase)값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당한다. (도대체 어디에 등록한다는거야?? 🤨)바로, 실행 컨텍스트(execution context)! 자바스크립트 엔진이 소스 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역.변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록된다. 변수 호이스팅(Variable Hoisting)📍변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징 12345console.log(name); //undefinedvar name = 'Jimmy';console.log(name); //'Jimmy' 호이스팅이 없었다면?변수 name을 선언하기 전에 console.log(name)을 통해 name을 참조하기 때문에 Reference Error가 발생해야 한다. 하지만, Reference Error 발생되지 않고 undefined가 출력된다. Why?? 바로 변수 호이스팅!모든 선언문은 런타임(코드가 한 줄씩 실행되는 시점) 이전 단계에서 실행된다.실행되면서 모든 값을 undefined로 초기화 된다. 사실 변수 선언뿐만이 아니라 함수, 클래스 선언문도 호이스팅된다. 변수에 값 할당(Assignment)📍123var score; //변수 선언score = 10; //값 할당 초기화 당시에 자바스크립트 엔진에 의해 undefined로 암묵적으로 할당된다. 그 이후에 새로운 값을 위해 메모리 공간을 확보하고 새로운 값을 저장하는 메모리 주소에 변수를 새롭게 mapping한다. 따라서, 엄밀히 말하자면 값을 할당할 때도 재할당된다. 1testScore = 100; // testScore가 선언되어있지 않음 선언되어 있지 않은 변수에 값을 할당하면 자바스크립트 엔진에 의해 전역변수(window객체)의 property로 지정된다. 변수에 값 재할당(Reassignment)📍12score = 10; //이미 score로 선언되었다고 가정score = 100; //100으로 재할당 원시값을 재할당 할 때 새로운 메모리 공간에 값을 재할당하고 변수를 그 주소로 새롭게 mapping해준다. 원시값은 변경불가능(immutable)! ES6에서 새롭게 도입된 const 키워드와 헷갈리지 말자! const 키워드는 재할당 불가능을 의미하고 원시값은 변경이 불가능하다는 뜻입니다. 식별자 네이밍 규칙📍▪️식별자는 특수문자를 제외한 문자, 숫자, underscore( _ ), 달러 기호($)를 포함할 수 있다.▪️단, 식별자는 특수문자를 제외한 문자, underscore( _ ),▪️달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.▪️예약어는 식별자로 사용할 수 없다. 123var first-name; // SyntaxError: Unexpected token – (연산자로 평가됨)var 1st; // SyntaxError: Invalid or unexpected tokenvar this; // SyntaxError: Unexpected token this 참고👏[PoiemaWeb] https://poiemaweb.com","link":"/2020/07/03/js/4.%20Variable/"},{"title":"제어문(Control Flow Statement)","text":"주어진 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용 일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다. 제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어 블록문(Block/Compound Statement) 0개 이상의 문을 중괄호로 묶은 것으로 코드 블록 자바스크립트는 블록문을 하나의 실행 단위로 취급 문의 끝에는 세미 콜론(;)을 붙이는 것이 일반적이지만 블록문의 끝에는 세미콜론을 붙이지 않는다 123456789101112131415161718// 블록문{ var foo = 10; console.log(foo);}// 제어문var x = 0;while (x &lt; 10) { x++;}console.log(x); // 10// 함수 선언문function sum(a, b) { return a + b;}console.log(sum(1, 2)); // 3 조건문(Conditional Statement) 주어진 조건식(conditional expression)의 평가 결과에 따라 코드 블럭(블록문)의 실행을 결정 조건식은 불리언 값으로 평가될 수 있는 표현식 코드 블록 내의 문이 하나뿐이라면 중괄호를 생략 가능 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768var num = 2;var kind;// if 문if (num &gt; 0) { kind = '양수'; // 음수를 구별할 수 없다}console.log(kind); // 양수// if…else 문if (num &gt; 0) { kind = '양수';} else { kind = '음수'; // 0은 음수가 아니다.}console.log(kind); // 양수// if…else if 문if (num &gt; 0) { kind = '양수';} else if (num &lt; 0) { kind = '음수';} else { kind = '영';}console.log(kind); // 양수//삼항 조건 연산자 사용var num = 2;// 0은 false로 취급된다.var kind = num ? (num &gt; 0 ? '양수' : '음수') : '영';console.log(kind); // 양수//switch문var year = 2000; // 2000년은 윤년으로 2월이 29일이다.var month = 2;var days = 0;switch (month) { case 1: case 3: case 5: case 7: case 8: case 10: case 12: days = 31; break; case 4: case 6: case 9: case 11: days = 30; break; case 2: // 윤년 계산 알고리즘 // 1. 년도가 4로 나누어 떨어지는 해는 윤년(2000, 2004, 2008, 2012, 2016, 2020…) // 2. 그 중에서 년도가 100으로 나누어 떨어지는 해는 평년(2000, 2100, 2200...) // 3. 그 중에서 년도가 400으로 나누어 떨어지는 해는 윤년(2000, 2400, 2800...) days = (year % 4 === 0 &amp;&amp; year % 100 !== 0) || year % 400 === 0 ? 29 : 28; break; default: console.log('Invalid month');}console.log(days); // 29 반복문(Loop Statement) 주어진 조건식의 평가 결과가 참인 경우 코드 블럭을 실행 그 후 조건식을 다시 검사하여 여전히 참인 경우 코드 블록을 다시 실행 조건식이 거짓일 때까지 반복 123456789101112131415161718192021222324// 중첩 for문for (var i = 1; i &lt;= 6; i++) { for (var j = 1; j &lt;= 6; j++) { if (i + j === 6) console.log(`[${i}, ${j}]`); }}// while문var count = 0;// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.while (count &lt; 3) { console.log(count); count++;} // 0 1 2// do...while문 (최소 한번 실행)var count = 0;// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.do { console.log(count); count++;} while (count &lt; 3); // 0 1 2 break문(Break Statement) 레이블 문, 반복문(for, for…in, for…of, while, do…while) 또는 switch 문의 코드 블록을 탈출 1234567891011121314151617181920212223242526272829303132if (true) { break; // Uncaught SyntaxError: Illegal break statement}// outer라는 식별자가 붙은 레이블 for 문outer: for (var i = 0; i &lt; 3; i++) { for (var j = 0; j &lt; 3; j++) { // i + j === 3이면 outer라는 식별자가 붙은 레이블 for 문을 탈출한다. if (i + j === 3) break outer; console.log('inner ' + j); }}console.log('Done!');// break문 예제var string = 'Hello World.';var search = 'l';var index;// 문자열은 유사배열이므로 for 문으로 순회할 수 있다.for (var i = 0; i &lt; string.length; i++) { // 문자열의 개별 문자가 'l'이면 if (string[i] === search) { index = i; break; // 반복문을 탈출한다. }}console.log(index); // 2// 참고로 String.prototype.indexOf 메소드를 사용해도 같은 동작을 한다.console.log(string.indexOf(search)); // 2 continue문(Continue Statement) continue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 이동 break 문처럼 반복문을 탈출하지는 않음 12345678910111213141516var string = 'Hello World.';var search = 'l';var count = 0;// 문자열은 유사배열이므로 for 문으로 순회할 수 있다.for (var i = 0; i &lt; string.length; i++) { // 'l'이 아니면 현 지점에서 실행을 중단하고 반복문의 증감식으로 이동한다. if (string[i] !== search) continue; count++; // continue 문이 실행되면 이 문은 실행되지 않는다.}console.log(count); // 3// 참고로 String.prototype.match 메소드를 사용해도 같은 동작을 한다.const regexp = new RegExp(search, 'g');console.log(string.match(regexp).length); // 3 참고 👏[PoiemaWeb] https://poiemaweb.com","link":"/2020/07/09/js/8.%20ControlFlowStatement/"},{"title":"데이터 타입(Data Type)","text":"데이터 타입이란? 📍데이터 타입이란 값의 종류를 말한다. 줄여서 타입이라고 말하기도 한다.자바스크립트의 모든 값은 데이터 타입을 갖는다. 그리고 원시타입과 객체타입으로 구분할 수 있다. 원시 타입과 객체 타입의 비교에 대해 좀 더 자세한 내용은👇원시값과 객체의 비교 데이터 타입의 필요성 📍그렇다면 데이터 타입이 왜 필요한 거야?? 🤔 1️⃣ 데이터 타입에 의한 메모리 공간의 확보와 참조 값은 메모리에 저장하고 참조할 수 있어야 한다. 먼저, 저장할 때를 생각해보자. 메모리에 값을 저장할 때 확보해야 할 메모리 공간의 크기를 알아야한다.(무작정 큰 거 주면 되겠지? 적당히~ 넉넉하게~ 🥴?? 너무 비효율적이다! 🤬)따라서, 자바스크립트 엔진은 값의 종류(데이터 타입)에 따라서 정해진 크기의 메모리 공간을 확보한다. 즉, 변수에 할당되는 데이터 타입에 따라 메모리의 공간의 크기가 결정된다. 값을 참조할때도 마찬가지로 메모리 공간의 크기를 알아야한다.몇 바이트를 읽어 들일건지 정해야 하기 때문이다. 12var a = 100;console.log(var); 위 코드를 보면 console.log(var)를 통해 변수 var를 참조한다. 그렇다면 컴퓨터는 몇 칸의 메모리 셀을 읽어들여야 할까?그걸 알려주는 것이 값의 타입이다.현재 변수 var는 number인 100이 할당되어 있다. 자바스크립트에서 number 타입은 8byte 단위로 저장되어 있으므로 8byte 단위로 값을 읽어 들인다. 2️⃣ 데이터 타입에 의한 값의 해석컴퓨터는 모든 값을 2진수로 처리한다.예를 들어, var b = 65에서 65도 사실은 메모리공간에 0과 1로만 저장되어있다.하지만, 메모리에 저장되어있는 01000001은 숫자로 해석하면 65이지만 문자열로 해석하면 ‘A’이다.이 때, 변수 b에 할당된 값이 숫자타입이였기 때문에 2진수를 숫자로 해석한다. 정리해보자면, 👉 값을 저장할 때 확보해야 하는 메모리 크기와 값을 참조할 때 한번에 읽어 들여야 할 메모리 크기를 결정한다.👉 메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정한다. 원시타입(Primitive Data Type)의 종류 📍자바스크립트의 원시타입에는 6개의 종류가 있다. ▪️number▪️string▪️boolean▪️null▪️undefined▪️symbol (ES6에서 추가되었다.) 숫자(number)자바스크립트에서 number는 모두 실수로 처리되며 8 byte이다. 모두 실수로 처리되기 때문에 소숫점이 없는 정수로 보여도 사실은 실수다.정수를 정수로 나눴을 때 결과값은 실수! 12var num = 7 / 2;console.log(num) = 3.5; //출력값: 3.5 또한 3가지 특별한 값들도 표현할 수 있다.∙ Infinity: 양의 무한대∙ -Infinity: 음의 무한대∙ NaN: 산술 연산 불가(Not-a-Number) 123console.log(10 / 0); // Infinityconsole.log(10 / -10); // -Infinityconsole.log(1 * 'String'); // NaN(Not-a-Number) 문자열(string)문자열은 0개 이상의 16bit 유니코드 문자(UTF-16)들의 집합이며 텍스트 데이터를 나타내는데 사용한다. 텍스트를 작은 따옴표(''), 큰 따옴표(&quot;&quot;), 또는 백틱(``)으로 감싸면 된다.백틱을 사용하면 ES6에서 추가된 템플릿 리터럴이라는 새로운 문자열 표기법이다. 문자열은 인덱스를 통해 접근 가능하다. 123var str = 'hello';str[0] = 'H';console.log(str); //출력값: 'hello'. 변경되지 않은 이유는 문자열은 immutable C언어와는 다르게 문자열은 원시타입이고 따라서 변경 불가능(immutable)하다.따라서, 새로운 문자열을 재할당하는 것은 가능하다.기존 문자열을 변경하는 것이 아니라 새로운 문자열을 새롭게 할당하는 것이다. 1234var str = 'hello';console.log(str); // 'hello'str += 'Jimmy';console.log(str); // 'helloJimmy' 템플릿 리터럴ES6부터 도입된 새로운 문자열 표기법이다. 백틱(``)사용한다. 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 여러가지의 편리한 문자열 처리 기능 제공한다. 템플릿 리터럴은 런타임에 일반 문자열로 변환되어 처리된다. 123456789// 멀티라인 문자열var template = `&lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Home&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;`;// 표현식 삽입var first = 'Jimmy';var last = 'Joo';console.log(`My name is ${first} ${last}.`); (템플릿 리터럴의 좀 더 자세한 내용은 나중에 정리를 해야겠다.특히 태그드 템플릿 기능에 대해 좀 더 공부가 필요하다. 📝) 불리언(boolean)논리적 참과 거짓을 나타낸다. 값은 참을 나타내는 true, 거짓을 나타내는 false 뿐이다. undefined(undefined)변수 선언 이후에 값을 할당하지 않으면 자바스크립트 엔진에 의해 변수의 값이 undefined로 초기화된다. 이를 통해 개발자가 변수를 참조할 때 undefined가 반환된다면 변수에 할당을 한 적이 없다는 것을 알 수 있다. 따라서 의도적으로 변수에 undefined를 할당하지 말자.변수에 값이 없다는 것을 명시하고 싶다면 null을 할당하자! null(null)의도적으로 변수에 값이 없다는 것을 명시하기 위한 값이다. 또한, 함수가 호출되었으나 유효한 값을 반환할 수 없는 경우, 명시적으로 null 반환하기도 한다. 아래 코드를 보면 document.querySelector 메소드는 myElem이라는 클래스를 가진 HTML요소를 검색할 수 없다.이럴 경우 에러가 아니라 null을 반환한다. 12var element = document.querySelector('.myElem');console.log(element); // null ❗️주의할점 typeof로 확인하면 object나온다.이럴때는 일치연산자(===) 사용해서 확인하자! symbol(symbol)심볼(symbol)은 ES6에서 추가되었다.주로 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키(property key)를 만들기 위해 사용한다. Symbol 함수를 호출해 생성한다. 이때 생성된 심볼 값은 노출되지 않고 다른 값과 절대 중복되지 않는 값이다. 12345var key = Symbol('key');var obj = {};obj[key] = 'value';console.log(obj[key]); // value 객체 타입(Object/Reference Data Type) 📍👉객체란 데이터(property)와 그 데이터에 관련한 동작(method)을 모두 포함할 수 있는 독립적 주체이다. 자바스크립트를 이루고 있는 거의 ‘모든 것’이 객체이다.원시 타입을 제외한 나머지 값들(배열, 함수, 정규표현식 등)은 모두 객체다. 객체의 중요한 특징은 참조에 의한 전달(pass-by-reference)이다. 객체(구체적으로 표현하자면 객체 리터럴)에 대한 내용은👇객체 정적 타입 언어와 동적 타입 언어 📍프로그래밍 언어를 타입 언어로 구분한다면 정적 타입 언어와 동적 타입 언어로 구분할 수 있다. 그렇다면 자바스크립트는 어떤 타입 언어일까?바로 동적 타입 언어! 동적 타입 언어에 대해 알아보기 전에 먼저 정적 타입 언어에 대해 알아보자. 정적 타입(Static/Strong type) 언어정적 타입 언어로는 대표적으로 C, C++, Java를 들 수 있다. 정적 타입 언어는 변수를 선언할 때 데이터 타입이 결정된다. 그리고 변수의 타입을 런타임에 변경할 수 없으며 변수에 선언한 타입에 맞는 값만을 할당할 수 있다. (컴파일 시점에 타입 체크를 통해 에러를 발생시키고 프로그램 실행 자체를 막는다.) 즉, 한 번 타입이 정해지면 런타임에는 변경할 수 없기 때문에 정적 타입 언어라 불린다. (좀 빡빡한 친구구만..🤨) 하지만, 타입의 일관성을 강제하여 보다 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄일 수 있다는 장점이 있다.👍 그렇다면 동적 타입 언어는 어떨까? 동적 타입(Dynamic/Weak type) 언어대표적으로 JavaScript, Python, Ruby 등을 들 수 있다. 동적 타입 언어는 값을 할당하는 시점에 변수의 타입이 결정된다. 정적 타입 언어와 가장 큰 차이점은 재할당에 의해 변수의 타입이 언제든지 자유롭게 변경 가능하다. 즉, 런타임에 동적으로 변수의 타입이 변경 가능하므로 동적 타입 언어라 불린다. 하지만, 단점으로는 변화하는 변수 값 추적하기 어렵고 값의 신뢰성이 떨어진다. (“chill”하고 “free”한 느낌? 🏝 대신 디버깅이 어렵다…🥵) 따라서, 변수를 사용할 때는 몇 가지를 주의하자! 🚨주의사항▪️변수를 남발하지 말자. 필요한 경우에 한해 제한적으로 사용하자.▪️유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제하자.▪️전역 변수의 사용은 지양하자.▪️변수보다는 상수를 사용해 값의 변경을 억제하자. (const)▪️명확하고 구체적인 변수명 네이밍을 통해 변수의 목적과 의미를 정확하게 전달하자 참고 👏 [MDN] https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures [PoiemaWeb] https://poiemaweb.com","link":"/2020/07/05/js/6.%20DataType/"},{"title":"원시 값과 객체의 비교","text":"원시타입 객체타입 값 변경여부 변경 불가능 변경 가능 저장되는 값 실제 값 저장 참조 값 저장 전달방식 값에 의한 전달(Pass by Value) 참조에 의한 전달(Pass by Reference) 값 변경 여부원시타입은 변경 불가능객체타입은 변경 가능 여기서 말하는 “변경 불가능”이 어떤 뜻일까? 변경이 불가능하다는 뜻은 메모리 영역에서의 변경이 불가능하다는 뜻이다.(재할당이랑 헷갈리지 말자). 변경 불가능 한 값(immutable) 변수 값은 변경 가능: 재할당에 의해서 값 자체는 변경 불가능(read-only) 문자열과 불변성 자바스크립트에서 문자열은 원시타입 -&gt; 변경 불가능 1234567var str = 'Hello';str = 'world!'; // 새로운 메모리 공간 확보 -&gt; 식별자 str는 'world!'를 가르킴str[0] = 'S'; // 원시값이기 때문에 변하지 않음. 에러발생 Xconsole.log(str); // -&gt; 'world!' 값에 의한 전달(Pass by Value) 1234567891011121314var score = 80;// 변수 copy에는 변수 score의 값 80이 복사되어 할당된다.var copy = score;console.log(score, copy); // 80 80console.log(score === copy); // true// 변수 score와 변수 copy의 값은 다른 메모리 공간에 저장된 별개의 값이다.// 따라서 변수 score의 값을 변경하여도 변수 copy의 값에는 어떠한 영향도 주지 않는다.score = 100;console.log(score, copy); // 100 80console.log(score === copy); // false 객체 프로퍼티 동적 추가/삭제 가능 변경 가능 한 값(mutable) 재할당 없이 객체를 직접 변경 가능 얕은 복사(shallow copy) 12345678910111213var person = { name: 'Lee',};// 프로퍼티 값 갱신person.name = 'Kim';// 프로퍼티 동적 생성person.address = 'Seoul';console.log(person); // {name: \"Kim\", address: \"Seoul\"}var newPerson = person; // shallow copy 참조에 의한 전달(Pass by Reference) 객체를 가르키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달 이렇게 될 경우, 두 변수 모두 같은 주소값을 가르킴 둘 중 한 객체가 변경될 경우, 다른 객체도 영향을 받음 1234567891011121314151617181920var person = { name: 'Jimmy',};// 참조 값을 복사. copy와 person은 동일한 참조 값을 갖는다.var copy = person;// copy와 person은 동일한 객체를 참조한다.console.log(copy === person); // true// copy를 통해 객체를 변경한다.copy.name = 'Joo';// person을 통해 객체를 변경한다.person.address = 'Seoul';// copy와 person은 동일한 객체를 가리키고 있다.// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.console.log(person); // {name: \"Joo\", address: \"Seoul\"}console.log(copy); // {name: \"Joo\", address: \"Seoul\"} 참고 👏[PoiemaWeb] https://poiemaweb.com","link":"/2020/07/15/js/11.%20TypeComparison/"},{"title":"표현식과 문(Expression &amp; Statement)","text":"값(Value)📍👉 식(표현식, Expression)이 평가(Evaluate)되어 생성된 결과 12345// 1+2라는 식이 평가되어 3이라는 숫자값을 생성1 + 2; // 3// sum이라는 변수에 1 + 2 라는 식이 평가되어 생성된 3이라는 숫자값을 할당var sum = 1 + 2; 값은 다양한 방법으로 생성할 수 있다.그 중에서 가장 기본적인 방법은 리터럴을 생성하는 것이다. 리터럴(Literal)📍👉 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기 방식 JS엔진이 런타임에 리터럴을 평가하여 값을 생성한다. 1234567893 // 정수 리터럴'Hello' // 문자열 리터럴true // 불리언 리터럴null // null 리터럴undefined // undefined 리터럴{ name : 'Jimmy'} // 객체 리터럴[1,2] // 배열 리터럴function() {} // 함수 리터럴/^[0-9]+$/ // 정규 표현식 리터럴 표현식(Expression)📍👉 값으로 평가될 수 있는 문(Statement) 표현식이 평가되면 값을 생성하거나 값을 참조한다.리터럴은 값으로 평가되기 때문에 리터럴도 표현식이다. 1234567891011121314151617// 리터럴 표현식(JS엔진에 의해 런타임에 평가되어 값 생성 =&gt; 표현식)100;('Jimmy');// 식별자 표현식(식별자 참조)var sum = 50;sum; // -&gt; 변수 sum에 100이라는 값이 할당되어 있다면 참조를 통해 값(100)이 평가됨 =&gt; 표현식person.name;// 연산자 표현식10 + 20;sum = 10;sum === 10; // true라는 값을 생성// 함수/메소드 호출 표현식getSum();person.getAge(); 표현식과 표현식이 평가된 값은 동치(equivalent)이다. 즉, 표현식을 값처럼 사용 가능 → 값이 위치할 수 있는 자리에 표현식도 위치할 수 있다. (e.g. 변수에 지정 가능) 문(Statement)📍👉 프로그램을 구성하는 기본 단위이자 최소 실행 단위 쉽게 말해 컴퓨터에 내리는 명령이다.그리고 문들은 토큰(token) 들로 구성되어있다. 토큰이란 문법적인 의미를 가지며, 문법적으로 더이상 나눌 수 없는 코드의 기본 요소를 말한다.예를 들어, 키워드, 식별자, 연산자, 리터럴, 세미콜론, 마침표 등이 있다. 1var product = 4 * 5; 문에는 여러 종류가 있다.대표적으로 선언문, 할당문, 조건문, 반복문으로 구분할 수 있다. 12345678910111213141516// 선언문var name;function getName() {}// 할당문name = 'Jimmy';// 조건문if (score &gt;= 90) { console.log('Your grade is A');}// 반복문for (var i = 0; i &lt; 10; i++) { console.log(i);} 세미콜론(Semicolon)📍세미콜론(;)은 문(statement)의 종료를 나타낸다. 따라서 문은 세미콜론으로 끝나야 한다.단, 0개 이상의 문을 중괄호({ })로 묶은 코드블록 뒤에는 붙이지 않는다. (e.g. if문, for문, 함수) 하지만, 세미콜론을 붙이는 것은 옵션!이다. 그 것은 바로 세미콜론 자동 삽입 기능(ASI, Automatic Semicolon Insertion) 때문이다.이 기능은 JS엔진이 코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여준다. ❗️문제점: 개발자의 의도와 다를수 있다. 표현식인 문과 표현식이 아닌 문📍표현식과 문의 개념을 헷갈리지 말자.🤯 문에는 표현식인 문과 표현식이 아닌 문이 있다.표현식인 문은 값으로 평가될 수 있는 문이다.표현식이 아닌 문은 값으로 평가될 수 없다. 간단하게 구분하는 방법이 있다.바로 변수에 할당하기!😎 표현식인 문은 값으로 평가되므로 변수에 할당이 가능하다.반대의 경우 에러🚫가 발생한다. 1234567// 선언문 =&gt; 값 평가 X, 즉 표현식이 아닌 문var x;var y = var x; // SyntaxError// 할당문 =&gt; 값으로 평가됨 =&gt; 표현식인 문x = 100;var y = x = 100; // x에 100 할당되고 y에 x의 값(100)이 할당됨 크롬 개발자 도구에서 표현식이 아닌 문은 언제나 undefined를 출력한다. 참고👏[PoiemaWeb] https://poiemaweb.com","link":"/2020/07/04/js/5.%20Expression&Statement/"},{"title":"타입 변환과 단축 평가(Type Conversion)","text":"명시적 타입 변환(Explicit coercion) 암묵적 타입 변환(Implicit coercion) 기존 원시값을 직접 변경 X,(원시값은 변경 불가능이기 때문) 새로운 원시값 생성. 암묵적 타입 변환 같은 경우, 암묵적 타입 변환(Implicit Coercion) 타입 강제 변환(Type coercion) 표현식을 평가하는 도중에 JS엔진에 의해 암묵적으로 타입이 변환 새로운 값을 만들었다가 한번 사용하고 표현식의 평가가 끝나면 가비지 컬렉터에 의해서 메모리에서 해제 문자열 타입으로 변환 + 연산자 피연산자 중 하나 이상이 문자열일 경우 문자열 연결 연산자로 동작 123456789101 + '2'; // \"12\"console.log(`1 + 1 = ${1 + 1}`); // 1 + 1 = 20 + ''; // \"0\"false + ''; // \"false\"null + ''; // \"null\"undefined + ''; // undefinedSymbol() + ''; // TypeError(function () {} + ''); // \"function(){}\" 숫자 타입으로 변환 JS엔진이 산술 연산자나 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환 피연산자를 숫자로 변경할 수 없는 경우 평가결과 NaN 1234567891011121 - '1'; // 01 * '10'; // 101 / 'one' + // NaN'' + // 0'0' + // 0'1' + // 1'String' + // NaNnull + // 1undefined + // NaNSymbol() + // TypeError[] + // 0 function () {}; //NaN 불리언 타입으로 변환 JS엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환시킴 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분 Falsy값 false undefined null 0, -0 NaN ''(빈 문자열) Truthy값: Falsy 값 이외의 모든 값 명시적 타입 변환(Explicit Coercion) 타입 캐스팅(Type casting) 개발자가 의도적으로 값의 타입을 변환 문자열 타입으로 변환1234567891011121314// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법console.log(String(1)); // \"1\"console.log(String(NaN)); // \"NaN\"console.log(String(true)); // \"true\"// 2. Object.prototype.toString 메소드를 사용하는 방법console.log((1).toString()); // \"1\"console.log(NaN.toString()); // \"NaN\"console.log(true.toString()); // \"true\"// 3. 문자열 연결 연산자를 이용하는 방법console.log(1 + ''); // \"1\"console.log(NaN + ''); // \"NaN\"console.log(true + ''); // \"true\" 숫자 타입으로 변환1234567891011121314// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법console.log(Number('10.53')); // 10.53console.log(Number(false)); // 0// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)console.log(parseFloat('10.53')); // 10.53// 3. + 단항 산술 연산자를 이용하는 방법console.log(+'10.53'); // 10.53console.log(+false); // 0// 4. * 산술 연산자를 이용하는 방법console.log('10.53' * 1); // 10.53console.log(false * 1); // 0 불리언 타입으로 변환12345678910111213141516171819// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법console.log(Boolean('')); // falseconsole.log(Boolean('false')); // trueconsole.log(Boolean(1)); // trueconsole.log(Boolean(NaN)); // falseconsole.log(Boolean(Infinity)); // trueconsole.log(Boolean(null)); // falseconsole.log(Boolean(undefined)); // falseconsole.log(Boolean([])); // true// 2. ! 부정 논리 연산자를 두번 사용하는 방법console.log(!!''); // falseconsole.log(!!'false'); // trueconsole.log(!!1); // trueconsole.log(!!NaN); // falseconsole.log(!!Infinity); // trueconsole.log(!!null); // falseconsole.log(!!undefined); // falseconsole.log(!![]); // true 단축 평가(Short-Circuit Evaluation) 논리합(||) 연산자와 논리곱(&amp;&amp;) 연산자 표현식의 결과는 불리언 값이 아닐 수도 있음 논리합(||), 논리곱(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가됨 단축평가 논리 연산의 결과를 결정한 타입 변환하지 않고 피연산자를 그대로 반환 표현식을 평가하는 도중에 평가 결과가 확정된 경우, 나머지 평가 과정을 중단 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 논리합(||) 연산자'Cat' || 'Dog'; // 'Cat'false || 'Dog'; // 'Dog''Cat' || false; // 'Cat'// 논리곱(&amp;&amp;) 연산자'Cat' &amp;&amp; 'Dog'; // Dogfalse &amp;&amp; 'Dog'; // false'Cat' &amp;&amp; false; // false// 논리곱(&amp;&amp;) 연산자 활용해 if문 대체 가능var done = true;var message = '';// 주어진 조건이 true일 때if (done) message = '완료';// if문은 단축 평가로 대체 가능하다.message = done &amp;&amp; '완료';console.log(message); // 완료// 객체가 null인지 확인하고 프로퍼티를 참조할 때var elem = null;console.log(elem.value); // TypeError: Cannot read property 'value' of nullconsole.log(elem &amp;&amp; elem.value); // null// 함수 매개변수에 기본값을 설정할 때// 단축 평가를 사용한 매개변수의 기본값 설정function getStringLength(str) { str = str || ''; return str.length;}getStringLength(); // 0getStringLength('hi'); // 2// ES6의 매개변수의 기본값 설정function getStringLength(str = '') { return str.length;}getStringLength(); // 0getStringLength('hi'); // 2 참고 👏[PoiemaWeb] https://poiemaweb.com","link":"/2020/07/11/js/9.%20TypeConversion/"},{"title":"연산자(Operator)","text":"연산자(Operator)하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산(operation) 등을 수행해 하나의 값을 만든다. 산수 연산자(Arithmetic Operator) 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 생성. 산술 연산이 불가능한 경우, NaN을 반환 이항 산수 연산자 피연산자 2개, 부수효과 X +(덧셈), -(뺄셈), *(곱셈), /(나눗셈), %(나머지) 단항 산수 연산자 피연산자 1개 ++(증가, 부수효과), --(감소, 부수효과), +, - 12345678910111213141516// '+' 연산자는 숫자타입이 아닌 피연산자를 숫자로 타입 변환한다.// 아무런 효과가 없다.+10; // -&gt; 10+-10; // -&gt; -10// 문자열을 숫자로 타입 변환한다.+'10'; // -&gt; 10// 불리언 값을 숫자로 타입 변환한다.+true; // -&gt; 1// 불리언 값을 숫자로 타입 변환한다.+false; // -&gt; 0// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.+'Hello'; // -&gt; NaN 문자열 연결 연산자 +연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작 1234567891011// 문자열 연결 연산자'1' + 2; // '12'// 타입변환1 + true; // 2(1 + 1)1 + false; // 1(false = 0)1 + null; // 1(null = 0)// undefined는 숫자로 타입 변환되지 않는다+undefined; // NaN1 + undefined; //NaN 할당 연산자(Assignment Operator) 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당 부수효과 O 123456789101112131415161718192021222324252627282930313233343536x = 10;console.log(x); // 10x += 5; // x = x + 5;console.log(x); // 15x -= 5; // x = x - 5;console.log(x); // 10x *= 5; // x = x * 5;console.log(x); // 50x /= 5; // x = x / 5;console.log(x); // 10x %= 5; // x = x % 5;console.log(x); // 0var str = 'My name is ';// 문자열 연결 연산자str += 'Lee'; // str = str + 'Lee';console.log(str); // 'My name is Lee'// 할당문은 표현식인 문이다.console.log((x = 10)); // 10var a, b, c;// 연쇄 할당. 오른쪽에서 왼쪽으로 진행.// ① c = 0 : 0으로 평가된다// ② b = 0 : 0으로 평가된다// ③ a = 0 : 0으로 평가된다a = b = c = 0;console.log(a, b, c); // 0 0 0 비교 연산자(Comparison Operator) 동등(loose) / 일치(strict) 비교 연산자 동등 비교(==): 암묵적 타입 변환을 통해 타입을 일치시킨 후, 같은 값인지 비교 일치 비교(===): 타입도 같고 값도 같은 경우에 한하여 true를 반환 +(덧셈), -(뺄셈), *(곱셈), /(나눗셈), %(나머지) 1234567891011121314// 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 동등하다.5 == '5'; // -&gt; true// 동등 비교. 결과를 예측하기 어렵다.'0' == ''; // -&gt; false0 == ''; // -&gt; true0 == '0'; // -&gt; truefalse == 'false'; // -&gt; falsefalse == '0'; // -&gt; truefalse == null; // -&gt; falsefalse == undefined; // -&gt; false// NaN은 자신과 일치하지 않는 유일한 값이다.NaN === NaN; // -&gt; false // 빌트인 함수 isNaN은 주어진 값이 NaN인지 체크하고 그 결과를 반환한다.isNaN(NaN); // -&gt; trueisNaN(10); // -&gt; falseisNaN(1 + undefined); // -&gt; true //ES6 Object.is methodObject.is(-0, +0); // -&gt; falseObject.is(NaN, NaN); // -&gt; true 12 비교 연산자(Comparison Operator) 피연산자의 크기를 비교하여 불리언 값을 반환 12345// 대소 관계 비교5 &gt; 0; // -&gt; true5 &gt; 5; // -&gt; false5 &gt;= 5; // -&gt; true5 &lt;= 5; // -&gt; true 비교 연산자(Ternary Operator) 조건식의 평가 결과에 따라 반환할 값을 결정 자바스크립트의 유일한 삼항 연산자이며 부수 효과 X 12345var x = 10;// 삼항 연산자 표현식은 표현식인 문이다. 따라서 값처럼 사용할 수 있다.var result = x % 2 ? '홀수' : '짝수';console.log(result); // 짝수 논리 연산자(Logical Operator) 우항과 좌항의 피연산자(부정 논리 연산자의 경우, 우항의 피연산자)를 논리 연산 부수 효과 X ||(OR, 논리합), &amp;&amp;(AND, 논리곱), !(NOT, 부정) 논리합(||) 또는 논리곱(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 어는 한쪽으로 평가 123456// 암묵적 타입 변환!0; // -&gt; true!'Hello'; // -&gt; false// 단축 평가'Cat' &amp;&amp; 'Dog'; // -&gt; 'Dog' 쉼표 연산자 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환 123var x, y, z;(x = 1), (y = 2), (z = 3); // 3 그룹 연산자 그룹 연산자를 사용하면 연산자의 우선 순위를 조절 12// 그룹 연산자를 사용하여 우선 순위 조절10 * (2 + 3); // -&gt; 50 typeof 연산자 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환 123var x, y, z;(x = 1), (y = 2), (z = 3); // 3 그룹 연산자 typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환 7가지 문자열 “string”, “number”, “boolean”, “undefined”, “symbol”, “object”, “function” 중 하나를 반환 null 타입을 확인할 때는 typeof 연산자를 사용하지 말고 일치 연산자(===)를 사용 선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 “undefined”를 반환 123456789101112131415typeof ''; // -&gt; \"string\"typeof 1; // -&gt; \"number\"typeof NaN; // -&gt; \"number\"typeof true; // -&gt; \"boolean\"typeof undefined; // -&gt; \"undefined\"typeof Symbol(); // -&gt; \"symbol\"typeof null; // -&gt; \"object\"typeof []; // -&gt; \"object\"typeof {}; // -&gt; \"object\"typeof new Date(); // -&gt; \"object\"typeof /test/gi; // -&gt; \"object\"typeof function () {}; // -&gt; \"function\"// 식별자 undeclared는 선언한 적이 없다.typeof undeclared; // -&gt; undefined 지수 연산자 ES7부터 도입 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 타입의 값을 반환 음수를 거듭제곱의 밑으로 계산하려면 아래와 같이 괄호로 묶어야 한다 12345678910111213142 ** 2; // -&gt; 42 ** 2.5; // -&gt; 5.656854249492382 ** 0; // -&gt; 12 ** -2; // -&gt; 0.25(-5) ** 2; // -&gt; 25var num = 5;num **= 2; // -&gt; 25//ES7 이전Math.pow(2, 2); // -&gt; 4Math.pow(2, 2.5); // -&gt; 5.65685424949238Math.pow(2, 0); // -&gt; 1Math.pow(2, -2); // -&gt; 0.25 연산자의 부수 효과 할당(=) 연산자, 증가/감소(++/–) 연산자, delete 연산자 123456789101112131415161718var x;// 할당 연산자는 변수 값이 변하는 부수 효과가 있다.// 이는 변수 x를 사용하는 다른 코드에 영향을 준다.x = 1;console.log(x); // 1// 증가/감소(++/--) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다.// 피연산자 x의 값이 변경된다. 이는 변수 x를 사용하는 다른 코드에 영향을 준다.x++;console.log(x); // 2var o = { a: 1 };// delete 연산자는 객체의 프로퍼티를 삭제하는 부수 효과가 있다.// 이는 객체 o를 사용하는 다른 코드에 영향을 준다.delete o.a;console.log(o); // {} 참고 👏[PoiemaWeb] https://poiemaweb.com","link":"/2020/07/08/js/7.%20Operator/"},{"title":"객체 리터럴(Object Literal)","text":"객체(Object)📍자바스크립트에서는 원시 값을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다. 객체란 데이터(property)와 그 데이터에 관련한 동작(method)을 모두 포함할 수 있는 독립적 주체이다. 프로퍼티란 객체의 상태를 나타내는 값이다.메소드란 프로퍼티를 참조하고 조작할 수 있는 동작이다. 😫 이것도 객체..? 저것도 객체..?? 자바스크립트를 공부하다보면 객체란 단어를 자주 접하게 된다.하지만 객체에 대한 개념을 정확하게 파악하지 못하면 오히려 더욱 헷갈리게 만든다. 먼저, 우리가 “자바스크립트에서는 원시 값을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다.” 라고 표현할 때 객체란 참조값을 저장하고, 참조에 의한 전달방식을 사용하고, 변경이 가능한(mutable) 객체/참조 타입을 의미하는 포괄적인 용어이다. 우리는 때론 객체 리터럴을 간편하게 객체라고 부를때도 있다. 여기서 말하는 객체란 중괄호를 사용해 값을 생성하는 방식인 객체 리터럴만을 의미한다. 객체 리터럴에 의한 객체 생성📍C++과 Java 같은 클래스 기반 객체지향 언어는 클래스를 사전에 정의하고 new 연산자와 함께 생성자(constructor)를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성한다. 자바스크립트에서는 프로토타입 기반 객체지향 언어로서 다양한 객체 생성 방법이 존재한다. 그 중에는 객체 리터럴, Object 생성자 함수, 생성자 함수, Object.create 메소드, 클래스가 있다. 오늘은 그 중에서 가장 일반적이고 간단한 객체 리터럴 방법에 대해서 알아보자. 복습을 해보자면 리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법이다. 객체 리터럴은 중괄호({...}) 내에 0개 이상의 프로퍼티를 정의하여 값을 생성하는 표기법이다. 변수에 할당이 이루어지는 시점에 JS엔진이 객체 리터럴을 해석하여 객체를 생성한다. 주의할점❗️객체 리터럴의 중괄호({})는 코드 블록 의미하지 않는다. 코드 블록의 닫는 중괄호 뒤에는 세미콜론(;)이 오지 않는다. 하지만, 객체 리터럴은 값으로 평가되는 표현식이다. 따라서, 닫는 중괄호 뒤에 세미콜론을 붙인다. 12345678910// 객체 생성var person = { name: 'Joo'; // 프로퍼티 sayHello: function() { // 메소드 console.log(`Hello! My name is ${this.name}.`); }};// 빈 객체 생성var emptyObject = {}; 프로퍼티(Property)📍프로퍼티란 객체의 상태를 나타내는 값(데이터)이며 키(key)과 값(value)으로 구성되어있다. 123456var obj = { myKey1: 'myValue1', 'my-key2': 'myValue2', 1: 10, myKey1: 'myValue3',}; 프로퍼티를 나열할 때 쉼표(,)로 구분한다.(마지막 프로퍼티 뒤에는 쉼표는 옵션) 프로퍼티 키빈 문자열을 포함하는 모든 문자열 또는 symbol값이 올 수 있다.프로퍼티 키가 식별자 네이밍 규칙 따르면 따옴표('') 생략 가능하지만 따르지 않으면 따옴표를 반드시 붙혀야한다.프로퍼티 키의 이름이 같은 경우 나중에 실행된 프로퍼티가 덮어쓴다. 만약 프로퍼티 키가 숫자라면 따옴표는 붙지 않지만 내부적으로는 문자열로 변환된다. 따라서 정확히 말하면 숫자가 아니라 문자열이다. 프로퍼티 값자바스크립트에서 사용할 수 있는 모든 값이 올 수 있다.number, string, boolean 같은 원시타입은 물론 함수나 배열 같은 객체타입도 올 수 있다. 객체리터럴({} 또한 가능하다. 프로퍼티 접근프로퍼티 접근 방법은 2가지가 있다. 1️⃣마침표 표기법(.)2️⃣대괄호 표기법([]) 대괄호 표기법은 대괄호 안에 반드시 따옴표로 감싼 문자열이 와야한다. 감싸지 않으면 식별자로 해석되기 때문이다. 프로퍼티 키가 식별자 네이밍 규칙을 따르는 마침표 표기법, 대괄표 표기법 둘 다 사용가능하나 따르지 않을 경우 대괄표 표기법만 가능하다. 객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다. 프로퍼티 키가 숫자로 이루어진 문자열인 경우, 따옴표를 생략 가능하다. 1234567891011121314151617181920212223242526var person = { name: 'Joo'; 'first-name': 'Jimmy'; 10: 100;};// 마침표 표기법에 의한 프로퍼티 접근console.log(person.name); // Joo// 대괄호 표기법에 의한 프로퍼티 접근console.log(person['name']); // Jooconsole.log(person[name]); // ReferenceError: name is not defined// 존재하지 않는 프로퍼티 접근console.log(person.age); // undefined// 프로퍼티 키가 유효하지 않은 이름일 경우 -&gt; 대괄호 사용!console.log(person.'first-name'); // SyntaxErrorconsole.log(person[first-name]); // ReferenceErrorconsole.log(person['first-name']); // Jimmy//프로퍼티 키가 숫자로 이루어진 문자열일 경우console.log(person.10); // SyntaxErrorconsole.log(person.'10'); // SyntaxErrorconsole.log(person[10]); // 100console.log(person['10']); // 100 프로퍼티 값 갱신/생성/삭제프로퍼티 값은 동적으로 갱신, 생성, 삭제가 가능하다. 이미 존재하는 프로퍼티에 값에 할당하면 프로퍼티 값이 갱신된다. 만약 존재하지 않는 프로퍼티에 값을 할당하면?? 🧐 새롭게 생성된다. 프로퍼티 삭제는 delete 연산자를 사용하자.없는 프로퍼티를 삭제해도 에러가 발생하지 않는다. 아무런 일도 발생하지 않는다. 123456789101112131415var person = { name: 'Jimmy';};// name 값 갱신person.name = 'Joo';console.log(person.name); // Joo// 프로퍼티 생성(해당 프로퍼티 존재하지 않을경우 생성, 존재할 경우 갱신)person.age = 27;console.log(person); {name: 'Joo', age: 27};// 존재하는 프로퍼티 삭제, 존재하지 않을 경우 무시(에러X)delete person.age;delete person.height; // 무시됨 메소드(Method)📍자바스크립트에서 모든 값은 프로퍼티의 값이 될 수 있다.자바스크립트의 함수는 일급 객체이므로 값이다.따라서, 함수 또한 프로퍼티의 값이 될 수 있다.객체의 프로퍼티의 값이 함수인 경우 메소드라 말한다. 즉, 메소드란 객체에 제한되어 있는 함수이다.메소드란 객체의 프로퍼티를 참조하거나 조작하는 함수에 한정지어 정의하는 것이 더 구체적일것이다. (객체의 프로퍼티를 조작하지 않는 함수의 경우 메소드라 부르기보단 차라리 프로퍼티 값이 일반함수라고 말하는게 오해의 소지가 없을수도 있다고 생각한다.) 123456var person = { name: 'Joo'; sayName(): function() { // 메소드 console.log('Hi! My name is ' + this.name); }} ES6에서 추가된 객체 리터럴의 확장 기능📍1️⃣프로퍼티 축약 표현프로퍼티 값으로 변수를 사용하는 경우, 변수 이름과 프로퍼티 키가 동일한 이름일 때, 프로퍼티 키를 생략 가능하다. 123456const firstName = 'Jimmy';const lastName = 'Joo';const obj = { firstName, lastName };console.log(obj); // {firstName: 'Jimmy', lastName: 'Joo'} 2️⃣프로퍼티 키 동적 생성객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성 가능하다. (그 전에는 외부에서만 가능했다.) 12345678910const prefix = 'prop';let i = 0;const obj = { [`${prefix}-${++i}`]: i, [`${prefix}-${++i}`]: i, [`${prefix}-${++i}`]: i,};console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3} 3️⃣메소드 축약 표현메소드 정의할 때, function 키워드를 생략 가능하다. 12345678const obj = { name: 'Jimmy', sayHi() { console.log(`Hi! My name is ${this.name}`); },};obj.sayHi(); //Hi! My name is Jimmy 참고 👏[PoiemaWeb] https://poiemaweb.com","link":"/2020/07/12/js/10.%20ObjectLiteral/"},{"title":"함수(Function)","text":"일련의 과정을 문(statement)들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것 매개변수(parameter): 함수 정의할 때 내부로 입력을 전달받는 변수 인수(argument): 함수 호출될 때 내부로 입력받는 값 반환 값(return value): 함수가 출력하는 값 함수 정의(function definition) 를 통해 함수를 생성 함수 호출(function call/invoke) 을 통해 함수 실행 함수의 필요성: 재사용성 및 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과 함수 리터럴 함수 이름 함수 이름은 식별자 -&gt; 네이밍 규칙 준수 함수 이름(식별자)은 함수 몸체 내에서만 참조 가능 함수 이름 생략 가능 기명 함수(named function): 이름 O 익명 함수(anonymous function): 이름 X 매개변수 목록 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분 매개변수에는 함수호출문의 인수가 순서대로 할당(순서 의미 O) 매개변수는 함수 몸체 내에서 변수와 동일하게 취급 -&gt; 식별자 네이밍 규칙을 준수 함수 몸체 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록 함수 몸체는 함수 호출에 의해 실행 함수 정의 함수 선언문(Function declaration/statement)123456789101112// 함수 선언문function add(x, y) { return x + y;}// 함수 참조// console.dir은 console.log와는 달리 함수 객체의 프로퍼티까지 출력한다.// 단, Node.js 환경에서는 console.log와 같은 결과가 출력된다.console.dir(add); // ƒ add(x, y)// 함수 호출console.log(add(2, 5)); // 7 함수 이름 생략 불가능 함수 선언문은 표현식이 아닌 문 12345678// 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없다.// 하지만 함수 선언문이 변수에 할당되는 것처럼 보인다.var add = function add(x, y) { return x + y;};// 함수 호출console.log(add(2, 5)); // 7 자바스크립트 엔진이 상황에 따라 동일한 함수 리터럴을 표현식이 아닌 문인 함수 선언문으로 해석하는 경우와 표현식인 문인 함수 리터럴 표현식으로 해석하는 경우가 있음 하지만 내부 동작에 차이가 있음 12345678910111213// 이름이 있는 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석한다.// 함수 선언문은 함수 이름을 생략할 수 없다.function foo() { console.log('foo');}foo(); // foo// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식로 해석한다.// 함수 리터럴은 함수 이름을 생략할 수 있다.(function bar() { console.log('bar');});bar(); // ReferenceError: bar is not defined 함수 선언문은 실행되어 함수 객체를 생성 -&gt; 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출 함수 이름과 변수 이름이 일치하므로 함수 이름으로 호출되는 듯 보이지만 사실은 식별자로 호출 함수 표현식(Function expression)1234567891011// 기명 함수 표현식var add = function foo (x, y) { return x + y;};// 함수 객체를 가리키는 식별자로 호출console.log(add(2, 5)); // 7// 함수 이름으로 호출하면 ReferenceError가 발생한다.// 함수 이름은 함수 몸체 내부에서만 유효한 식별자이다.console.log(foo(2, 5)); // ReferenceError: foo is not defined 생성자 함수(Constructor function)- 자바스크립트가 기본 제공하는 빌트인 함수인 Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출하면 함수 객체를 생성하여 반환 - Function 생성자 함수로 생성한 함수는 클로저를 생성하지 않는 등, 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작 123456789101112131415var add1 = (function () {var a = 10;return function (x, y) { return x + y + a; };}());console.log(add1(1, 2)); // 13var add2 = (function () { var a = 10; return new Function('x', 'y', 'return x + y + a;');}());console.log(add2(1, 2)); // ReferenceError: a is not defined 화살표 함수(Arrow function))- ES6에서 새롭게 도입 - function 키워드 대신 화살표(=&gt;, Fat arrow)를 사용 - 화살표 함수는 항상 익명 함수로 정의 - 생성자 함수로 사용할 수 없으며 기존의 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 arguments 객체를 생성 X 1234// 화살표 함수const add = (x, y) =&gt; x + y;console.log(add(2, 5)); // 7 함수 생성 시점과 함수 호이스팅 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다름 1234567891011121314151617// 함수 참조console.dir(add); // ƒ add(x, y)console.dir(sub); // undefined// 함수 호출console.log(add(2, 5)); // 7console.log(sub(2, 5)); // TypeError: sub is not a function// 함수 선언문function add(x, y) { return x + y;}// 함수 표현식var sub = function (x, y) { return x - y;}; 함수 호이스팅(Function hoisting) 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징 함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성 -&gt; 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당 런타임에는 이미 함수 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당까지 완료된 상태 -&gt; 함수 선언문 이전에 함수를 참조할 수 있으며 호출 가능 변수 호이스팅? 함수 호이스팅? var 키워드로 사용한 변수 선언문과 함수 선언문은 모두 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 식별자를 생성한다는 점에서 동일 변수 호이스팅: var 키워드로 선언된 변수는 undefined로 초기화 함수 호이스팅: 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화 따라서 var 키워드로 사용한 변수 선언문 이전에 변수를 참조하면 변수 호이스팅에 의해 undefined로 평가되지만 함수 선언문으로 정의한 함수를 함수 선언문 이전에 호출하면 함수 호이스팅에 의해 호출이 가능 변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 됨 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생 함수 표현식 이전에 함수를 참조하면 undefined으로 평가 -&gt; 이때 함수를 호출하면 undefined를 호출하는 것과 마찬가지이므로 타입 에러(TypeError)가 발생 즉, 함수 표현식으로 함수를 정의하였으면 함수 표현식 이후에 참조 및 호출 함수 호출(Function call/invoke) 함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 컨트롤을 넘김 123456789// 함수 선언문function add(x, y) { console.log(x, y); // 2 5 return x + y;}// 함수 호출// 인수 1과 2는 매개변수 x와 y에 순서대로 할당되고 함수 몸체의 문들이 실행된다.var result = add(1, 2); 매개변수와 인수 매개변수는 함수 몸체 내부에서만 참조 가능. (= 매개변수의 스코프는 함수 내부) 인수가 부족하여 인수가 할당되지 않은 매개변수의 값은 undefined 인수 &gt; 매개변수 -&gt; 초과되는 인수 무시(암묵적으로 argument 객체의 프로퍼티로 보관) 12345678910111213function add(x, y) { console.log(x, y); // 2 5 return x + y;}// 함수 add의 매개변수 x, y는 함수 몸체 내부에서만 참조할 수 있다.console.log(x, y); // ReferenceError: x is not defined// 인수 &lt; 매개변수 (2 + undefined = NaN)console.log(add(2)); // NaN// 인수 &gt; 매개변수console.log(add(2, 3, 4)); // 5 인수 확인 매개변수와 인수의 개수가 일치하는지 확인 X 매개변수의 타입을 사전에 지정할 수 없음 여러 방법을 통해 예외 처리 1234567891011121314151617// 인수가 부족할 경우 NaN 결과값을 방지하기 위해 초기값(undefined -&gt; 0) 지정function add(a, b, c) { a = a || 0; b = b || 0; c = c || 0; return a + b + c;}console.log(add(1, 2, 3)); // 6console.log(add(1, 2)); // 3console.log(add(1)); // 1console.log(add()); // 0// ES6function add(a = 0, b = 0, c = 0) { return a + b + c;} 반환문 return: 실행 결과를 함수 외부로 반환 함수의 실행을 중단하고 함수 몸체를 빠져나감 -&gt; 그 이후의 문은 실행 X 1234567function multiply(x, y) { return x * y; // 반환문 // 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다. console.log('실행되지 않는다.');}console.log(multiply(3, 5)); // 15 return 키워드 뒤에 지정한 값을 반환(지정하지 않으면 undefined 반환) 123456789101112function foo () { // return 키워드 뒤에 반환값을 명시적으로 지정하지 않으면 undefined가 반환된다. return;}function bar() {// 반환문을 생략하면 암묵적으로 undefined가 반환된다.}console.log(foo()); // undefinedconsole.log(bar()); // undefined} 참조에 의한 전달과 외부 상태의 변경 매개변수에 원시타입이 들어올 경우: 함수 내에서 원시값이 변경되어도 외부 원시타입에 영향 X 매개변수에 객체타입가 들어올 경우: 함수 내에서 객체가 변경되면 외부 객체에 영향 123456789101112131415161718192021// 매개변수 primitive는 원시값을 전달받고, 매개변수 obj는 객체를 전달받는다.function changeVal(primitive, obj) { primitive += 100; obj.name = 'Jimmy';}// 외부 상태var num = 100;var person = { name: 'Joo' };console.log(num); // 100console.log(person); // {name: \"Joo\"}// 원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달된다.changeVal(num, person);// 원시 값은 원본이 훼손되지 않는다.console.log(num); // 100// 객체는 원본이 훼손된다.console.log(person); // {name: \"Jimmy\"} 다양한 함수의 형태1. 즉시실행함수(IIFE, Immediately Invoked Function Expression) 함수 정의와 동시에 즉시 호출되는 함수 단 한번만 호출되며 재호출 불가능 일반적으로 익명 함수 반드시 그룹 연산자(…)로 감싸주어야 함 사용하는 이유: 인위적인 scope 생성 closure 1234567891011121314151617(function () { var a = 3; var b = 5; return a * b;})();// 즉시 실행 함수에도 일반 함수처럼 인수를 전달할 수 있다.res = (function (a, b) { return a * b;})(3, 5);console.log(res); // 15// 이런 방식으로도 사용가능. 화살표 함수와 같은 형태 -&gt; (...)그룹연산자로 감싸고 ( )호출res = (function (a, b) { return a * b;})(3, 5); 2. 재귀함수(Recursive function) 자기 자신을 호출하는 함수 재귀 함수는 자신을 무한 재귀 호출 -&gt; 따라서 재귀 함수 내에는 재귀 호출을 멈출 수 있는 탈출 조건이 반드시 존재해야 함. 탈출 조건이 없는 경우, 함수가 무한 호출되어 stack overflow 에러가 발생 1234567891011121314// 팩토리얼(계승)은 1부터 자신까지의 모든 양의 정수의 곱이다.// n! = 1 * 2 * ... * (n-1) * nfunction factorial(n) { // 탈출 조건: n이 1 이하일 때 재귀 호출을 멈춘다. if (n &lt;= 1) return 1; // 재귀 호출 return n * factorial(n - 1);}console.log(factorial(0)); // 0! = 1console.log(factorial(1)); // 1! = 1console.log(factorial(2)); // 2! = 2 * 1 = 2console.log(factorial(3)); // 3! = 3 * 2 * 1 = 6console.log(factorial(4)); // 4! = 4 * 3 * 1 * 1 = 24 3. 중첩 함수(Nested function) 중첩함수: 함수 내부에 정의된 함수 = 내부 함수(inner function) 중첩 함수를 포함하는 함수 = 외부 함수(outer function) 일반적으로 중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수(helper function)의 역할 1234567891011121314function outer() { var x = 1; // 중첩 함수 function inner() { var y = 2; // 외부 함수의 변수를 참조할 수 있다. console.log(x + y); // 3 } inner();}outer(); 4. 콜백 함수(Callback function) 함수의 매개변수를 통해 전달되는 함수 고차 함수(Higher-Order Function, HOF): 콜백 함수를 매개변수를 통해 전달받은 함수 고차 함수는 콜백 함수를 자신의 일부분으로 합성 고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정하여 호출 1234567891011121314151617181920212223242526272829303132// 외부에서 전달받은 f를 n만큼 반복 호출한다function repeat(n, f) { for (var i = 0; i &lt; n; i++) { // i를 전달하면서 f를 호출 f(i); }}var logAll = function (i) { console.log(i);};// 반복 호출할 함수를 인수로 전달한다.repeat(5, logAll); // 0 1 2 3 4var logOdds = function (i) { if (i % 2) console.log(i);};// 반복 호출할 함수를 인수로 전달한다.repeat(5, logOdds); // 1 3// 배열의 값에 value(10)를 곱함console.log([1, 2, 3, 4, 5].map(function (v) { return v * 10;}); // -&gt; [10, 20, 30, 40, 50]// 배열의 값에 value(2)를 곱함console.log([1, 2, 3, 4, 5].map(function (v) { return v * 2;}); // -&gt; [2, 4, 6, 8, 10] 5. 순수/비순수 함수(Pure/Impure function) 순수 함수: 부수효과 X 비순수 함수: 부수효과 O 12345678910111213141516171819202122var count = 0; // 현재 카운트를 나타내는 상태// 외부 상태에 의존하지 않으며 변경하지도 않는 순수 함수// 순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.function increase(n) { return ++n;}// 순수 함수가 반환한 결과값을 변수에 재할당하여 상태를 변경count = increase(count);console.log(count); // 1count = 0;// 함수의 외부 상태에 의존하여 외부 상태에 따라 반환값이 달라지는 비순수 함수// 비순수 함수는 외부 상태를 변경하는 부수 효과(side effect)가 있다.function increase() { return ++count; // 외부 상태를 변경한다.}// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다.increase();console.log(count); // 1 참고 👏[PoiemaWeb] https://poiemaweb.com","link":"/2020/07/18/js/12.%20Function/"},{"title":"프로그래머스 - 완주하지 못한 선수","text":"LINK: 프로그래머스 - 완주하지 못한 선수 문제 📝 나의 풀이 🤔1234567891011function solution(participant, completion) { // 1️⃣ participant.sort(); completion.sort(); // 2️⃣ for (let i = 0; i &lt; participant.length; i++) { // 3️⃣ if (participant[i] !== completion[i]) return participant[i]; }} 1️⃣ participant와 completion 배열을 sort 함수를 통해 정렬시킨다.2️⃣ particpant 배열의 길이만큼 for문을 순회한다.3️⃣ 정렬 해주었기 때문에 순서대로 비교하며 다를 경우를 확인한다. participant 배열에 한명이 더 많기 때문에 다르다는 것은 participant 배열에 있는 사람이 완주하지 못한 선수라는 뜻이다. 다른 사람의 풀이 👏12345678function solution(participant, completion) { participant.sort(); completion.sort(); for (let i in participant) { if (participant[i] !== completion[i]) return participant[i]; }} 👉 차이점은 for...in문과 for문이다. 댓글에 보면 성능적인 차이가 있다고 한다. for문이 for...in문에 비해 좀 더 성능적으로 우수하다는 의견이 있다. 이 부분에 대해서는 좀 더 공부해보는걸로! 추가 학습 내용 🔎sort 함수 👉 https://jimmyjoo.github.io/2020/09/14/js/Sort/ for문(성능) 👉","link":"/2020/09/14/algorithms/hash_unfinished/"},{"title":"배열 정렬 메소드, Sort()","text":"sort() 메서드란? 📍sort() 메서드는 배열의 요소를 적절하게 정렬할 때 유용하다. (오름차순👆 또는 내림차순👇) 그렇다면 먼저 어떻게 생겼는지(문법)에 대해 살펴보자! 😎 문법 📍array.sort([compareFunction]) 매개변수(parameter)로 비교함수를 받을 수 있다. ( 좀 더 자세한 설명은 아래서 👇) 설명 📍sort 메서드는 원본 배열을 직접 변경하여 정렬된 배열을 반환한다.(이렇게 원본 배열을 직접 변경하는 메소드를 “mutator method”라고 부른다.이와 상반되는 메소드는 “accessor method”라고 부른다. 예를 들어, map이나 filter 메소드는 원본 배열을 변경하지 않고 새로운 배열을 생성하여 반환한다. ) 기본 정렬 순서는 오름차순이다.하지만 정확히 표현하자면 문자열의 유니코드 코드 포인트를 따른다!따라서, 배열의 요소가 숫자 타입이여도 배열의 요소를 일시적으로 문자열로 변환 후 문자열의 유니코드를 비교하여 정렬한다. 예시 코드를 보며 좀 더 살펴보자. 1234567891011// 1️⃣ 과일배열(fruits) 정렬const fruits = ['Banana', 'Apple', 'Orange'];fruits.sort();console.log(fruits);// ['Apple', 'Banana', 'Orange']// 2️⃣ 점수배열(scores) 정렬const scores = [2, 3, 10, 1, 100];scores.sort();console.log(scores);// [1, 10, 100, 2, 3] 👉 먼저 1️⃣, 2️⃣ 케이스 둘 다 원본 배열이 수정되었다. 👉 1️⃣부터 살펴보자. “abcdefg~”🎶 알파벳 순서대로 잘 정렬되었다. 👍 👉 문자열을 비교할때는 Unicode 값으로 비교하며 한 글자씩 비교한다.‘J’ &gt; ‘a’는 false: 알파벳은 Unicode에서 대문자 이후에 소문자가 오기 때문에 소문자가 더 크다. ‘Java’ &gt; ‘a’는 false: 한 글자씩 비교한다. ‘Java’ &gt; ‘Apple’는 true: 한 글자씩 비교한다. (‘J’와 ‘A’를 비교하면 같은 대문자고 ‘J’가 나중에 오기때문에 true) 👉 그렇다면 2️⃣는?예상했던 결과는 [1, 2, 3, 10, 100]였지만 막상 결과는 전혀 엉뚱하게 정렬된 배열이다. [1, 10, 100, 2, 3] ?! 🧐 그 이유는 sort() 메서드는 문자열의 유니코드 코드 포인트에 따라 정렬하기 때문! 배열의 요소들이 숫자이지만 비교하기 위해서 일시적으로 문자열로 변환된다.[2, 3, 10, 1, 100] → ['2', '3', '10', '1', '100'] 문자열 1의 Unicode 코드 포인트 U+0031문자열 2의 Unicode 코드 포인트 U+0032👉 1의 Unicode 코드 포인트가 앞서므로 1이 2보다 앞으로 정렬된다. 10과 2의 경우문자열 10의 Unicode 코드 포인트 U+0031U+0030문자열 2의 Unicode 코드 포인트 U+0032👉10의 Unicode 코드 포인트가 앞서므로 10이 2보다 앞으로 정렬된다. 그렇다면 숫자를 정렬할 때 Unicode의 코드 포인트 기준이 아니라 우리가 원래 원했던대로 정렬하고 싶다면 어떻게 해야될까? 그러기 위해선 비교함수(Compare function)에 대해 알아보자! 🔍 비교 함수(compare function) 📍비교 함수란 정렬 순서를 정의하는 함수이다. 위에서 살펴보았듯이 생략할 경우 각 문자의 Unicode 코드 포인트 값에 따라 정렬한다. 비교 함수의 형식은 다음과 같다. 12345678910function compare(a, b) { if (a is less than b by some ordering criterion) { return -1; } if (a is greater than b by the ordering criterion) { return 1; } // a must be equal to b return 0;} 👉비교함수는 두 개의 매개변수(a, b)를 받고 비교함수 내부의 로직을 실행하여 비교한다. 👉비교함수의 반환값이 음수면 순서를 그대로 유지하고반환값이 양수이면 b를 a보다 우선하여 정렬한다.반환값이 0인 경우 서로에 대해 변경하지 않고 모든 다른 요소에 대해 정렬합니다.(❗️ECMAscript 표준은 이러한 동작을 보장하지 않으므로 모든 브라우저(예 : Mozilla 버전은 적어도 2003 년 이후 버전 임)가 이를 존중하지는 않습니다. ) 다음은 숫자를 오름차순으로 정렬하는 코드이다.천천히 원리를 이해해보자! 1234const scores = [2, 3, 10, 1, 100];scores.sort((a, b) =&gt; a - b);console.log(scores);// [1, 2, 3, 10, 100] 👉 sort 메소드의 매개변수로 익명 화살표 함수 (a, b) =&gt; a - b를 비교 함수로써 넘겼다. ❗️쉬운 이해를 위해 매우 간단하게 설명하겠습니다. 👉 첫번째로, a: 2, b: 3을 대입해서 함수를 실행하면 반환값은 -1(음수)이다. 따라서, 순서는 그대로 유지된다.👉 10과 1를 정렬해보자. 10 - 1 을 해보면 9(양수)를 반환한다. 따라서, 순서는 뒤 바뀌게 되고 1은 10보다 우선 정렬된다. ❗️구글 크롬의 경우 콘솔로 찍어서 확인해보면 예상과 달리 a는 2가 아니라 3이 온다. 이에 대해서는 좀 더 공부가 필요할것같다. (추측하건대 내부적으로 Timsort 알고리즘을 사용하는데 아마 그것때문이 아닐까…? 🤔) 👉 하지만, a가 3이고 b를 2로 여긴다는것은 배열의 순서가 [3, 2, …]인 상태이고 반환값이 양수(+)가 되어서 순서가 바뀌게 된다. 즉, 2가 우선 정렬된다는 뜻이다.따라서, 직관적으로 a는 2, b는 3이라고 여겨도 무방하게 같은 정렬된 배열을 얻을 수 있다. 예제 📍숫자 배열 오름차순 정렬 123const scores = [2, 3, 10, 1, 100];scores.sort((a, b) =&gt; a - b);console.log(scores); 숫자 배열 내림차순 정렬 123const scores = [2, 3, 10, 1, 100];scores.sort((a, b) =&gt; a - b);console.log(scores); 비 ASCII 문자 정렬 1234const items = ['réservé', 'premier', 'cliché', 'communiqué', 'café', 'adieu'];items.sort((a, b) =&gt; a.localeCompare(b));// items is ['adieu', 'café', 'cliché', 'communiqué', 'premier', 'réservé'] 👉localeCompare() 메서드는 기준 문자열과 비교했을 때 비교 대상 문자열이 정렬상 전에 오는지, 후에 오는지 혹은 같은 순서에 배치되는지를 알려주는 숫자를 리턴한다. 👉 a.localeCompare(b)일때a가 b보다 전에 오면 -(음수)a가 b보다 후에 오면 +(양수)같으면 0 객체를 요소로 갖는 배열 정렬 123456789101112131415161718192021222324252627282930const fruits = [ { name: 'Banana', price: 100 }, { name: 'Apple', price: 75 }, { name: 'Orange', price: 20 },];// 비교함수const compare = (key) =&gt; (a, b) =&gt; { return a[key] &gt; a[key] ? 1 : a[key] &lt; b[key] ? -1 : 0;};// name으로 정렬console.log(fruits.sort(compare('name')));/* [ { name: 'Apple', score: 75 }, { name: 'Banana', price: 100 }, { name: 'Orange', score: 20},] */// price로 정렬console.log(fruits.sort(compare('price')));/* [ { name: 'Orange', score: 20}, { name: 'Apple', score: 75 }, { name: 'Banana', price: 100 },] */ 참고👏 [MDN] https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sort [PoiemaWeb] https://poiemaweb.com/js-array","link":"/2020/09/14/js/Sort/"},{"title":"프로그래머스 - 두 개 뽑아서 더하기","text":"LINK: 프로그래머스 - 두 개 뽑아서 더하기 문제 📝 나의 풀이 🤔12345678910111213141516function solution(numbers) { // 1️⃣ const sumArr = []; // 2️⃣ for (let i = 0; i &lt; numbers.length - 1; i++) { for (let j = i + 1; j &lt; numbers.length; j++) { sumArr.push(numbers[i] + numbers[j]); } } // 3️⃣ const answer = [...new Set(sumArr)].sort((a, b) =&gt; a - b); return answer;} 1️⃣ 두 개의 수를 저장할 배열(sumArr)을 const 키워드로 선언해준다. 2️⃣에서 배열에 두 수의 합을 push를 해줄거지만 배열자체의 reference가 재할당(re-assign)이 되지 않기 때문에 문제가 되지 않는다. 2️⃣ numbers 배열을 이중순회하면서 요소들을 더하고 결과를 sumArr에 push한다. 바깥 for문은 총 numbers.length-1만큼 순회한다. numbers.length만큼보다 하나 작은 이유는 마지막 요소는 어차피 그 다음 요소가 없기 때문에 더할것이 없고 안쪽 for문도 무시된다. 따라서 애초에 바깥 for문을 시작할 필요조차 없다. 안쪽 for문의 경우 인덱스(j)는 i보다 하나 큰 수에서 시작한다. 3️⃣ new Set(sumArr)을 통해 중복요소를 제거해준 Set을 만든다. 그 다음 배열의 요소들을 정렬하기 위해 유용한 메서드 sort()를 사용하려고 한다. 그러나 Set은 배열이 아니라 사용하지 못하기 때문에 객체디스트럭쳐링을 한 이후에 배열 안에 담아준다. 그리고 오름차순으로 정렬시킨다. 추가 학습 내용 🔎자바스크립트 Set 👉","link":"/2020/09/15/algorithms/sum_array/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"variable","slug":"variable","link":"/tags/variable/"},{"name":"hoisting","slug":"hoisting","link":"/tags/hoisting/"},{"name":"naming rules","slug":"naming-rules","link":"/tags/naming-rules/"},{"name":"expression","slug":"expression","link":"/tags/expression/"},{"name":"statement","slug":"statement","link":"/tags/statement/"},{"name":"data type","slug":"data-type","link":"/tags/data-type/"},{"name":"operator","slug":"operator","link":"/tags/operator/"},{"name":"control flow","slug":"control-flow","link":"/tags/control-flow/"},{"name":"type conversion","slug":"type-conversion","link":"/tags/type-conversion/"},{"name":"object","slug":"object","link":"/tags/object/"},{"name":"property","slug":"property","link":"/tags/property/"},{"name":"method","slug":"method","link":"/tags/method/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"pass-by-value","slug":"pass-by-value","link":"/tags/pass-by-value/"},{"name":"pass-by-reference","slug":"pass-by-reference","link":"/tags/pass-by-reference/"},{"name":"poiemaweb","slug":"poiemaweb","link":"/tags/poiemaweb/"},{"name":"function","slug":"function","link":"/tags/function/"},{"name":"algorithms","slug":"algorithms","link":"/tags/algorithms/"},{"name":"programmers","slug":"programmers","link":"/tags/programmers/"},{"name":"hash","slug":"hash","link":"/tags/hash/"},{"name":"array","slug":"array","link":"/tags/array/"},{"name":"sort","slug":"sort","link":"/tags/sort/"}],"categories":[{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"algorithms","slug":"algorithms","link":"/categories/algorithms/"}]}