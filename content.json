{"pages":[],"posts":[{"title":"변수(Variable)란?","text":"하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름 식별자: 값이 아니라 메모리 주소를 기억. 즉, 매핑관계를 가지며 이 매핑정보도 메모리에 저장 변수선언(Declaration) 값을 저장하기 위한 메모리 공간 확보(allocate) 후 변수 이름과 메모리 주소 연결 확보 해제 전까지 메모리 공간 보호 12// 변수 선언문var name; 메모리 상에 공간을 확보하고 메모리 주소에 name(변수명)을 mapping해줌 선언 단계(Declaration phase): 변수 이름을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다. 초기화 단계(Initialization phase): 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당한다. 실행 컨텍스트(execution context): 자바스크립트 엔진이 소스 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역. 변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록됨. 변수 호이스팅(Variable Hoisting) 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징 123console.log(name); //undefinedvar name = 'Jimmy';console.log(name); //'Jimmy' 모든 선언문(declaration)은 런타임 이전 단계에서 실행됨 실행되면서 모든 값을 Undefined로 초기화 됨 따라서 reference error 발생되지 않고 undefined 출력 변수에 값 할당(Assignment)12var score; //변수 선언score = 10; //값 할당 초기화 당시에 undefined로 할당됨 그 이후에 새로운 값을 위해 메모리 공간을 확보하고 새로운 값을 저장하는 메모리 주소에 변수를 새롭게 mapping 따라서 값을 할당할 때도 사실상 재할당 1testScore = 100; // testScore가 선언되어있지 않음 선언되어 있지 않은 변수에 값을 할당하면 자바스크립트 엔진에 의해 전역변수의 property로 지정 변수에 값 재할당(Reassignment)12score = 10; //이미 score로 선언되었다고 가정score = 100; //100으로 재할당 원시값을 재할당 할 때 새로운 메모리 공간에 값을 재할당하고 변수를 그 주소로 새롭게 mapping해줍니다. 원시값은 변경불가능(immutable) ES6에서 새롭게 도입된 const 키워드와 헷갈리시면 안됩니다. const 키워드는 재할당 불가능을 의미하고 원시값은 변경이 불가능하다는 뜻입니다. 가비지 컬렉터(Garbage Collector):애플리케이션이 할당(allocate)한 메모리 공간을 주기적으로 검사하여 더 이상 사용되고 있지 않는 메모리를 해제(release). 더 이상 사용되고 있지 않는 메모리란 간단히 말하자면 어떤 식별자도 참조하고 있지 않는 메모리 공간을 의미. 자바스크립트는 가비지 컬렉터를 내장하고 있는 매니지드 언어이다. 이를 통해 메모리 누수(memory leak)를 방지 식별자 네이밍 규칙 식별자는 특수문자를 제외한 문자, 숫자, underscore( _ ), 달러 기호($)를 포함할 수 있다. 단, 식별자는 특수문자를 제외한 문자, underscore( _ ), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다. 예약어는 식별자로 사용할 수 없다. 123var first-name; // SyntaxError: Unexpected token – (연산자로 평가됨)var 1st; // SyntaxError: Invalid or unexpected tokenvar this; // SyntaxError: Unexpected token this 참고: [PoiemaWeb] https://poiemaweb.com","link":"/2020/07/03/js/Variable/"},{"title":"타입 변환과 단축 평가(Type Conversion)","text":"명시적 타입 변환(Explicit coercion) 암묵적 타입 변환(Implicit coercion) 기존 원시값을 직접 변경 X,(원시값은 변경 불가능이기 때문) 새로운 원시값 생성. 암묵적 타입 변환 같은 경우, 암묵적 타입 변환(Implicit Coercion) 타입 강제 변환(Type coercion) 표현식을 평가하는 도중에 JS엔진에 의해 암묵적으로 타입이 변환 새로운 값을 만들었다가 한번 사용하고 표현식의 평가가 끝나면 가비지 컬렉터에 의해서 메모리에서 해제 문자열 타입으로 변환 + 연산자 피연산자 중 하나 이상이 문자열일 경우 문자열 연결 연산자로 동작 123456789101 + '2'; // \"12\"console.log(`1 + 1 = ${1 + 1}`); // 1 + 1 = 20 + ''; // \"0\"false + ''; // \"false\"null + ''; // \"null\"undefined + ''; // undefinedSymbol() + ''; // TypeError(function () {} + ''); // \"function(){}\" 숫자 타입으로 변환 JS엔진이 산술 연산자나 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환 피연산자를 숫자로 변경할 수 없는 경우 평가결과 NaN 1234567891011121 - '1'; // 01 * '10'; // 101 / 'one' + // NaN'' + // 0'0' + // 0'1' + // 1'String' + // NaNnull + // 1undefined + // NaNSymbol() + // TypeError[] + // 0 function () {}; //NaN 불리언 타입으로 변환 JS엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환시킴 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분 Falsy값 false undefined null 0, -0 NaN ''(빈 문자열) Truthy값: Falsy 값 이외의 모든 값 명시적 타입 변환(Explicit Coercion) 타입 캐스팅(Type casting) 개발자가 의도적으로 값의 타입을 변환 문자열 타입으로 변환1234567891011121314// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법console.log(String(1)); // \"1\"console.log(String(NaN)); // \"NaN\"console.log(String(true)); // \"true\"// 2. Object.prototype.toString 메소드를 사용하는 방법console.log((1).toString()); // \"1\"console.log(NaN.toString()); // \"NaN\"console.log(true.toString()); // \"true\"// 3. 문자열 연결 연산자를 이용하는 방법console.log(1 + ''); // \"1\"console.log(NaN + ''); // \"NaN\"console.log(true + ''); // \"true\" 숫자 타입으로 변환1234567891011121314// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법console.log(Number('10.53')); // 10.53console.log(Number(false)); // 0// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)console.log(parseFloat('10.53')); // 10.53// 3. + 단항 산술 연산자를 이용하는 방법console.log(+'10.53'); // 10.53console.log(+false); // 0// 4. * 산술 연산자를 이용하는 방법console.log('10.53' * 1); // 10.53console.log(false * 1); // 0 불리언 타입으로 변환12345678910111213141516171819// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법console.log(Boolean('')); // falseconsole.log(Boolean('false')); // trueconsole.log(Boolean(1)); // trueconsole.log(Boolean(NaN)); // falseconsole.log(Boolean(Infinity)); // trueconsole.log(Boolean(null)); // falseconsole.log(Boolean(undefined)); // falseconsole.log(Boolean([])); // true// 2. ! 부정 논리 연산자를 두번 사용하는 방법console.log(!!''); // falseconsole.log(!!'false'); // trueconsole.log(!!1); // trueconsole.log(!!NaN); // falseconsole.log(!!Infinity); // trueconsole.log(!!null); // falseconsole.log(!!undefined); // falseconsole.log(!![]); // true 단축 평가(Short-Circuit Evaluation) 논리합(||) 연산자와 논리곱(&amp;&amp;) 연산자 표현식의 경가 결과는 불리언 값이 아닐 수도 있음 논리합(||), 논리곱(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가됨 단축평가 논리 연산의 결과를 결정한 타입 변환하지 않고 피연산자를 그대로 반환 표현식을 평가하는 도중에 평가 결과가 확정된 경우, 나머지 평가 과정을 중단 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 논리합(||) 연산자'Cat' || 'Dog'; // 'Cat'false || 'Dog'; // 'Dog''Cat' || false; // 'Cat'// 논리곱(&amp;&amp;) 연산자'Cat' &amp;&amp; 'Dog'; // Dogfalse &amp;&amp; 'Dog'; // false'Cat' &amp;&amp; false; // false// 논리곱(&amp;&amp;) 연산자 활용해 if문 대체 가능var done = true;var message = '';// 주어진 조건이 true일 때if (done) message = '완료';// if문은 단축 평가로 대체 가능하다.message = done &amp;&amp; '완료';console.log(message); // 완료// 객체가 null인지 확인하고 프로퍼티를 참조할 때var elem = null;console.log(elem.value); // TypeError: Cannot read property 'value' of nullconsole.log(elem &amp;&amp; elem.value); // null// 함수 매개변수에 기본값을 설정할 때// 단축 평가를 사용한 매개변수의 기본값 설정function getStringLength(str) { str = str || ''; return str.length;}getStringLength(); // 0getStringLength('hi'); // 2// ES6의 매개변수의 기본값 설정function getStringLength(str = '') { return str.length;}getStringLength(); // 0getStringLength('hi'); // 2","link":"/2020/07/06/js/TypeConversion/"},{"title":"원시 값과 객체의 비교","text":"원시타입 객체타입 값 변경여부 변경 불가능 변경 가능 저장되는 값 실제 값 저장 참조 값 저장 전달방식 값에 의한 전달(Pass by Value) 참조에 의한 전달(Pass by Reference) 원시 값 변경 불가능 한 값(immutable) 변수 값은 변경 가능: 재할당에 의해서 값 자체는 변경 불가능(read-only) 문자열과 불변성 자바스크립트에서 문자열은 원시타입 -&gt; 변경 불가능 1234567var str = 'Hello';str = 'world!'; // 새로운 메모리 공간 확보 -&gt; 식별자 str는 'world!'를 가르킴str[0] = 'S'; // 원시값이기 때문에 변하지 않음. 에러발생 Xconsole.log(str); // -&gt; 'world!' 값에 의한 전달(Pass by Value) 1234567891011121314var score = 80;// 변수 copy에는 변수 score의 값 80이 복사되어 할당된다.var copy = score;console.log(score, copy); // 80 80console.log(score === copy); // true// 변수 score와 변수 copy의 값은 다른 메모리 공간에 저장된 별개의 값이다.// 따라서 변수 score의 값을 변경하여도 변수 copy의 값에는 어떠한 영향도 주지 않는다.score = 100;console.log(score, copy); // 100 80console.log(score === copy); // false 객체 프로퍼티 동적 추가/삭제 가능 변경 가능 한 값(mutable) 재할당 없이 객체를 직접 변경 가능 얕은 복사(shallow copy) 12345678910111213var person = { name: 'Lee',};// 프로퍼티 값 갱신person.name = 'Kim';// 프로퍼티 동적 생성person.address = 'Seoul';console.log(person); // {name: \"Kim\", address: \"Seoul\"}var newPerson = person; // shallow copy 참조에 의한 전달(Pass by Reference) 객체를 가르키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달 이렇게 될 경우, 두 변수 모두 같은 주소값을 가르킴 둘 중 한 객체가 변경될 경우, 다른 객체도 영향을 받음 1234567891011121314151617181920var person = { name: 'Jimmy',};// 참조 값을 복사. copy와 person은 동일한 참조 값을 갖는다.var copy = person;// copy와 person은 동일한 객체를 참조한다.console.log(copy === person); // true// copy를 통해 객체를 변경한다.copy.name = 'Joo';// person을 통해 객체를 변경한다.person.address = 'Seoul';// copy와 person은 동일한 객체를 가리키고 있다.// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.console.log(person); // {name: \"Joo\", address: \"Seoul\"}console.log(copy); // {name: \"Joo\", address: \"Seoul\"}","link":"/2020/07/07/js/TypeComparison/"},{"title":"표현식과 문(Expression &amp; Statement)","text":"값(Value) 식(표현식, Expression)이 평가(Evaluate)되어 생성된 결과 12345// 1+2라는 식이 평가되어 3이라는 숫자값을 생성1 + 2; // 3// 변수에 1 + 2 라는 식이 평가되어 생성된 3이라는 숫자값을 할당var sum = 1 + 2; 식(Expression)뿐만이 아니라 리터럴 사용하여 값 생성 가능 리터럴(Literal) 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기 방식 1234567893 // 정수 리터럴'Hello' // 문자열 리터럴true // 불리언 리터럴null // null 리터럴undefined // undefined 리터럴{ name : 'Jimmy'} // 객체 리터럴[1,2] // 배열 리터럴function() {} // 함수 리터럴/^[0-9]+$/ // 정규 표현식 리터럴 JS엔진이 런타임에 리터럴을 평가하여 값을 생성 표현식(Expression) 값으로 평가될 수 있는 문(Statement) 표현식이 평가되면 값을 생성하거나 값을 참조 12345678910111213141516// 리터럴 표현식(JS엔진에 의해 런타임에 평가되어 값 생성 =&gt; 표현식)100;('Jimmy');// 식별자 표현식( 이미 선언되어 있다고 가정. 식별자 참조)sum; // -&gt; 변수 sum에 100이라는 값이 할당되어 있다면 참조를 통해 값(100)이 평가됨 =&gt; 표현식person.name;// 연산자 표현식10 + 20;sum = 10;sum === 10; // true라는 값을 생성// 함수/메소드 호출 표현식getSum();person.getAge(); 표현식과 표현식이 평가된 값은 동치(equivalent) 즉, 표현식을 값처럼 사용 가능 =&gt; 값이 위치할 수 있는 자리에 표현식도 위치할 수 있다(e.g. 변수에 지정 가능) 문(Statement) 프로그램을 구성하는 기본 단위이자 최소 실행 단위 컴퓨터에 내리는 명령 토큰(token) 들로 구성. 토큰: 문법적인 의미를 가지며, 문법적으로 더이상 나눌 수 없는 코드의 기본 요소 1var product = 4 * 5; e.g. 키워드(var), 식별자(product), 연산자(=,*), 리터럴(4,5), 세미콜론(;) 문의 종류 12345678910111213141516// 선언문var name;function getName() {}// 할당문name = 'Jimmy';// 조건문if (score &gt;= 90) { console.log('Your grade is A');}// 반복문for (var i = 0; i &lt; 10; i++) { console.log(i);} 세미콜론(Semicolon) 문(statement)의 종료를 나타냄 0개 이상의 문을 중괄호({ })로 묶은 코드블록 뒤에는 붙이지 않음(e.g. if문, for문, 함수) 옵션!(=생략가능) 세미콜론 자동 삽입 기능(ASI, Automatic Semicolon Insertion): JS엔진이 코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여줌 문제점: 개발자의 의도와 다를수 있음 표현식인 문과 표현식이 아닌 문 구분하는 방법: 변수에 할당(표현식인 문은 값으로 평가되므로 변수에 할당 가능. 반대의 경우 에러 발생) 1234567// 선언문 =&gt; 값 평가 X, 즉 표현식이 아닌 문var x;var y = var x; // SyntaxError// 할당문 =&gt; 값으로 평가됨 =&gt; 표현식인 문x = 100;var y = x = 100; // x에 100 할당되고 y에 x의 값(100)이 할당됨 크롬 개발자 도구에서 표현식이 아닌 문은 언제나 undefined를 출력 참고: [PoiemaWeb] https://poiemaweb.com","link":"/2020/07/04/js/Expression&Statement/"}],"tags":[],"categories":[{"name":"javascript","slug":"javascript","link":"/categories/javascript/"}]}